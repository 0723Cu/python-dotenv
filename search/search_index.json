{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"_______ . __ __ . ____ ____ | ____ || \\ | | \\ \\ / / | | __ | \\ | | \\ \\ / / | __ | | . ` | \\ / __ | | ____ | | \\ | \\ / ( __ ) | _______ || __ | \\ __ | \\ __ / python-dotenv | Reads the key-value pair from .env file and adds them to environment variable. It is great for managing app settings during development and in production using 12-factor principles. Do one thing, do it well! Usages The easiest and most common usage consists on calling load_dotenv when the application starts, which will load environment variables from a file named .env in the current directory or any of its parents or from the path specificied; after that, you can just call the environment-related method you need as provided by os.getenv . .env looks like this: # a comment that will be ignored. REDIS_ADDRESS = localhost:6379 MEANING_OF_LIFE = 42 MULTILINE_VAR = \"hello\\nworld\" You can optionally prefix each line with the word export , which is totally ignored by this library, but might allow you to source the file in bash. export S3_BUCKET = YOURS3BUCKET export SECRET_KEY = YOURSECRETKEYGOESHERE .env can interpolate variables using POSIX variable expansion, variables are replaced from the environment first or from other values in the .env file if the variable is not present in the environment. ( Note : Default Value Expansion is not supported as of yet, see #30 .) CONFIG_PATH = ${ HOME } /.config/foo DOMAIN = example.org EMAIL = admin@ ${ DOMAIN } Getting started Install the latest version with: pip install -U python-dotenv Assuming you have created the .env file along-side your settings module. . \u251c\u2500\u2500 . env \u2514\u2500\u2500 settings . py Add the following code to your settings.py : # settings.py from dotenv import load_dotenv load_dotenv () # OR, the same with increased verbosity load_dotenv ( verbose = True ) # OR, explicitly providing path to '.env' from pathlib import Path # python3 only env_path = Path ( '.' ) / '.env' load_dotenv ( dotenv_path = env_path ) At this point, parsed key/value from the .env file is now present as system environment variable and they can be conveniently accessed via os.getenv() : # settings.py import os SECRET_KEY = os . getenv ( \"EMAIL\" ) DATABASE_PASSWORD = os . getenv ( \"DATABASE_PASSWORD\" ) load_dotenv do not override existing System environment variables. To override, pass override=True to load_dotenv() . load_dotenv also accepts encoding parameter to open the .env file. The default encoding is platform dependent (whatever locale.getpreferredencoding() returns), but any encoding supported by Python can be used. See the codecs module for the list of supported encodings. You can use find_dotenv() method that will try to find a .env file by (a) guessing where to start using __file__ or the working directory -- allowing this to work in non-file contexts such as IPython notebooks and the REPL, and then (b) walking up the directory tree looking for the specified file -- called .env by default. from dotenv import load_dotenv , find_dotenv load_dotenv ( find_dotenv ()) In-memory filelikes It is possible to not rely on the filesystem to parse filelikes from other sources (e.g. from a network storage). load_dotenv and dotenv_values accepts a filelike stream . Just be sure to rewind it before passing. >>> from io import StringIO # Python2: from StringIO import StringIO >>> from dotenv import dotenv_values >>> filelike = StringIO ( 'SPAM=EGGS \\n ' ) >>> filelike . seek ( 0 ) >>> parsed = dotenv_values ( stream = filelike ) >>> parsed [ 'SPAM' ] 'EGGS' The returned value is dictionary with key-value pair. dotenv_values could be useful if you need to consume the envfile but not apply it directly into the system environment. Django If you are using Django, you should add the above loader script at the top of wsgi.py and manage.py . IPython Support You can use dotenv with IPython. You can either let the dotenv search for .env with %dotenv or provide the path to the .env file explicitly; see below for usages. %load_ext dotenv # Use find_dotenv to locate the file %dotenv # Specify a particular file %dotenv relative / or / absolute / path / to / . env # Use '-o' to indicate override of existing variables %dotenv - o # Use '-v' to turn verbose mode on %dotenv - v Command-line Interface For command-line support, use the CLI option during installation: pip install -U \"python-dotenv[cli]\" A CLI interface dotenv is also included, which helps you manipulate the .env file without manually opening it. The same CLI installed on remote machine combined with fabric (discussed later) will enable you to update your settings on a remote server; handy, isn't it! Usage : dotenv [ OPTIONS ] COMMAND [ ARGS ]... This script is used to set , get or unset values from a . env file . Options : - f , -- file PATH Location of the . env file , defaults to . env file in current working directory . - q , -- quote [ always | never | auto ] Whether to quote or not the variable values . Default mode is always . This does not affect parsing . -- help Show this message and exit . Commands : get Retrive the value for the given key . list Display all the stored key / value . run Run command with environment variables from . env file present set Store the given key / value . unset Removes the given key . Setting config on Remote Servers We make use of excellent Fabric to accomplish this. Add a config task to your local fabfile; dotenv_path is the location of the absolute path of .env file on the remote server. # fabfile.py import dotenv from fabric.api import task , run , env # absolute path to the location of .env on remote server. env . dotenv_path = '/opt/myapp/.env' @task def config ( action = None , key = None , value = None ): '''Manage project configuration via .env e.g: fab config:set,<key>,<value> fab config:get,<key> fab config:unset,<key> fab config:list ''' run ( 'touch %(dotenv_path)s ' % env ) command = dotenv . get_cli_string ( env . dotenv_path , action , key , value ) run ( command ) Usage is designed to mirror the Heroku config API very closely. Get all your remote config info with fab config : $ fab config foo = \"bar\" Set remote config variables with fab config:set,<key>,<value> : $ fab config:set,hello,world Get a single remote config variables with fab config:get,<key> : $ fab config:get,hello Delete a remote config variables with fab config:unset,<key> : $ fab config:unset,hello Thanks entirely to fabric and not one bit to this project, you can chain commands like so: fab config:set,<key1>,<value1> config:set,<key2>,<value2> $ fab config:set,hello,world config:set,foo,bar config:set,fizz = buzz Related Projects Honcho - For managing Procfile-based applications. django-dotenv django-environ django-configuration dump-env environs dynaconf","title":"Home"},{"location":"#python-dotenv","text":"Reads the key-value pair from .env file and adds them to environment variable. It is great for managing app settings during development and in production using 12-factor principles. Do one thing, do it well!","title":"python-dotenv |"},{"location":"#usages","text":"The easiest and most common usage consists on calling load_dotenv when the application starts, which will load environment variables from a file named .env in the current directory or any of its parents or from the path specificied; after that, you can just call the environment-related method you need as provided by os.getenv . .env looks like this: # a comment that will be ignored. REDIS_ADDRESS = localhost:6379 MEANING_OF_LIFE = 42 MULTILINE_VAR = \"hello\\nworld\" You can optionally prefix each line with the word export , which is totally ignored by this library, but might allow you to source the file in bash. export S3_BUCKET = YOURS3BUCKET export SECRET_KEY = YOURSECRETKEYGOESHERE .env can interpolate variables using POSIX variable expansion, variables are replaced from the environment first or from other values in the .env file if the variable is not present in the environment. ( Note : Default Value Expansion is not supported as of yet, see #30 .) CONFIG_PATH = ${ HOME } /.config/foo DOMAIN = example.org EMAIL = admin@ ${ DOMAIN }","title":"Usages"},{"location":"#getting-started","text":"Install the latest version with: pip install -U python-dotenv Assuming you have created the .env file along-side your settings module. . \u251c\u2500\u2500 . env \u2514\u2500\u2500 settings . py Add the following code to your settings.py : # settings.py from dotenv import load_dotenv load_dotenv () # OR, the same with increased verbosity load_dotenv ( verbose = True ) # OR, explicitly providing path to '.env' from pathlib import Path # python3 only env_path = Path ( '.' ) / '.env' load_dotenv ( dotenv_path = env_path ) At this point, parsed key/value from the .env file is now present as system environment variable and they can be conveniently accessed via os.getenv() : # settings.py import os SECRET_KEY = os . getenv ( \"EMAIL\" ) DATABASE_PASSWORD = os . getenv ( \"DATABASE_PASSWORD\" ) load_dotenv do not override existing System environment variables. To override, pass override=True to load_dotenv() . load_dotenv also accepts encoding parameter to open the .env file. The default encoding is platform dependent (whatever locale.getpreferredencoding() returns), but any encoding supported by Python can be used. See the codecs module for the list of supported encodings. You can use find_dotenv() method that will try to find a .env file by (a) guessing where to start using __file__ or the working directory -- allowing this to work in non-file contexts such as IPython notebooks and the REPL, and then (b) walking up the directory tree looking for the specified file -- called .env by default. from dotenv import load_dotenv , find_dotenv load_dotenv ( find_dotenv ())","title":"Getting started"},{"location":"#in-memory-filelikes","text":"It is possible to not rely on the filesystem to parse filelikes from other sources (e.g. from a network storage). load_dotenv and dotenv_values accepts a filelike stream . Just be sure to rewind it before passing. >>> from io import StringIO # Python2: from StringIO import StringIO >>> from dotenv import dotenv_values >>> filelike = StringIO ( 'SPAM=EGGS \\n ' ) >>> filelike . seek ( 0 ) >>> parsed = dotenv_values ( stream = filelike ) >>> parsed [ 'SPAM' ] 'EGGS' The returned value is dictionary with key-value pair. dotenv_values could be useful if you need to consume the envfile but not apply it directly into the system environment.","title":"In-memory filelikes"},{"location":"#django","text":"If you are using Django, you should add the above loader script at the top of wsgi.py and manage.py .","title":"Django"},{"location":"#ipython-support","text":"You can use dotenv with IPython. You can either let the dotenv search for .env with %dotenv or provide the path to the .env file explicitly; see below for usages. %load_ext dotenv # Use find_dotenv to locate the file %dotenv # Specify a particular file %dotenv relative / or / absolute / path / to / . env # Use '-o' to indicate override of existing variables %dotenv - o # Use '-v' to turn verbose mode on %dotenv - v","title":"IPython Support"},{"location":"#command-line-interface","text":"For command-line support, use the CLI option during installation: pip install -U \"python-dotenv[cli]\" A CLI interface dotenv is also included, which helps you manipulate the .env file without manually opening it. The same CLI installed on remote machine combined with fabric (discussed later) will enable you to update your settings on a remote server; handy, isn't it! Usage : dotenv [ OPTIONS ] COMMAND [ ARGS ]... This script is used to set , get or unset values from a . env file . Options : - f , -- file PATH Location of the . env file , defaults to . env file in current working directory . - q , -- quote [ always | never | auto ] Whether to quote or not the variable values . Default mode is always . This does not affect parsing . -- help Show this message and exit . Commands : get Retrive the value for the given key . list Display all the stored key / value . run Run command with environment variables from . env file present set Store the given key / value . unset Removes the given key .","title":"Command-line Interface"},{"location":"#setting-config-on-remote-servers","text":"We make use of excellent Fabric to accomplish this. Add a config task to your local fabfile; dotenv_path is the location of the absolute path of .env file on the remote server. # fabfile.py import dotenv from fabric.api import task , run , env # absolute path to the location of .env on remote server. env . dotenv_path = '/opt/myapp/.env' @task def config ( action = None , key = None , value = None ): '''Manage project configuration via .env e.g: fab config:set,<key>,<value> fab config:get,<key> fab config:unset,<key> fab config:list ''' run ( 'touch %(dotenv_path)s ' % env ) command = dotenv . get_cli_string ( env . dotenv_path , action , key , value ) run ( command ) Usage is designed to mirror the Heroku config API very closely. Get all your remote config info with fab config : $ fab config foo = \"bar\" Set remote config variables with fab config:set,<key>,<value> : $ fab config:set,hello,world Get a single remote config variables with fab config:get,<key> : $ fab config:get,hello Delete a remote config variables with fab config:unset,<key> : $ fab config:unset,hello Thanks entirely to fabric and not one bit to this project, you can chain commands like so: fab config:set,<key1>,<value1> config:set,<key2>,<value2> $ fab config:set,hello,world config:set,foo,bar config:set,fizz = buzz","title":"Setting config on Remote Servers"},{"location":"#related-projects","text":"Honcho - For managing Procfile-based applications. django-dotenv django-environ django-configuration dump-env environs dynaconf","title":"Related Projects"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of python-dotenv simply run: pip install python-dotenv OR poetry add python-dotenv OR pipenv install python-dotenv Changelog Latest ... 0.10.3 Improve interactive mode detection ( @andrewsmith )( #183 ). Refactor parser to fix parsing inconsistencies ( @bbc2 )( #170 ). Interpret escapes as control characters only in double-quoted strings. Interpret # as start of comment only if preceded by whitespace. 0.10.2 Add type hints and expose them to users ( @qnighy )( #172 ) load_dotenv and dotenv_values now accept an encoding parameter, defaults to None ( @theskumar )( @earlbread )( #161 ) Fix str / unicode inconsistency in Python 2: values are always str now. ( @bbc2 )( #121 ) Fix Unicode error in Python 2, introduced in 0.10.0. ( @bbc2 )( #176 ) 0.10.1 Fix parsing of variable without a value ( @asyncee )( @bbc2 )( #158 ) 0.10.0 Add support for UTF-8 in unquoted values ( @bbc2 )( #148 ) Add support for trailing comments ( @bbc2 )( #148 ) Add backslashes support in values ( @bbc2 )( #148 ) Add support for newlines in values ( @bbc2 )( #148 ) Force environment variables to str with Python2 on Windows ( @greyli ) Drop Python 3.3 support ( @greyli ) Fix stderr/-out/-in redirection ( @venthur ) 0.9.0 Add --version parameter to cli ( @venthur ) Enable loading from current directory ( @cjauvin ) Add 'dotenv run' command for calling arbitrary shell script with .env ( @venthur ) 0.8.1 Add tests for docs ( @Flimm ) Make 'cli' support optional. Use pip install python-dotenv[cli] . ( @theskumar ) 0.8.0 set_key and unset_key only modified the affected file instead of parsing and re-writing file, this causes comments and other file entact as it is. Add support for export prefix in the line. Internal refractoring ( @theskumar ) Allow load_dotenv and dotenv_values to work with StringIO()) ( @alanjds )( @theskumar )( #78 ) 0.7.1 Remove hard dependency on iPython ( @theskumar ) 0.7.0 Add support to override system environment variable via .env. ( @milonimrod ) ( #63 ) Disable \".env not found\" warning by default ( @maxkoryukov ) ( #57 ) 0.6.5 Add support for special characters \\ . ( @pjona ) ( #60 ) 0.6.4 Fix issue with single quotes ( @Flimm ) ( #52 ) 0.6.3 Handle unicode exception in setup.py ( #46 ) 0.6.2 Fix dotenv list command ( @ticosax ) Add iPython Suport ( @tillahoffmann ) 0.6.0 Drop support for Python 2.6 Handle escaped charaters and newlines in quoted values. (Thanks @iameugenejo ) Remove any spaces around unquoted key/value. (Thanks @paulochf ) Added POSIX variable expansion. (Thanks @hugochinchilla ) 0.5.1 Fix find_dotenv - it now start search from the file where this function is called from. 0.5.0 Add find_dotenv method that will try to find a .env file. (Thanks @isms ) 0.4.0 cli: Added -q/--quote option to control the behaviour of quotes around values in .env . (Thanks @hugochinchilla ). Improved test coverage.","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of python-dotenv simply run: pip install python-dotenv OR poetry add python-dotenv OR pipenv install python-dotenv","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#latest","text":"...","title":"Latest"},{"location":"CHANGELOG/#0103","text":"Improve interactive mode detection ( @andrewsmith )( #183 ). Refactor parser to fix parsing inconsistencies ( @bbc2 )( #170 ). Interpret escapes as control characters only in double-quoted strings. Interpret # as start of comment only if preceded by whitespace.","title":"0.10.3"},{"location":"CHANGELOG/#0102","text":"Add type hints and expose them to users ( @qnighy )( #172 ) load_dotenv and dotenv_values now accept an encoding parameter, defaults to None ( @theskumar )( @earlbread )( #161 ) Fix str / unicode inconsistency in Python 2: values are always str now. ( @bbc2 )( #121 ) Fix Unicode error in Python 2, introduced in 0.10.0. ( @bbc2 )( #176 )","title":"0.10.2"},{"location":"CHANGELOG/#0101","text":"Fix parsing of variable without a value ( @asyncee )( @bbc2 )( #158 )","title":"0.10.1"},{"location":"CHANGELOG/#0100","text":"Add support for UTF-8 in unquoted values ( @bbc2 )( #148 ) Add support for trailing comments ( @bbc2 )( #148 ) Add backslashes support in values ( @bbc2 )( #148 ) Add support for newlines in values ( @bbc2 )( #148 ) Force environment variables to str with Python2 on Windows ( @greyli ) Drop Python 3.3 support ( @greyli ) Fix stderr/-out/-in redirection ( @venthur )","title":"0.10.0"},{"location":"CHANGELOG/#090","text":"Add --version parameter to cli ( @venthur ) Enable loading from current directory ( @cjauvin ) Add 'dotenv run' command for calling arbitrary shell script with .env ( @venthur )","title":"0.9.0"},{"location":"CHANGELOG/#081","text":"Add tests for docs ( @Flimm ) Make 'cli' support optional. Use pip install python-dotenv[cli] . ( @theskumar )","title":"0.8.1"},{"location":"CHANGELOG/#080","text":"set_key and unset_key only modified the affected file instead of parsing and re-writing file, this causes comments and other file entact as it is. Add support for export prefix in the line. Internal refractoring ( @theskumar ) Allow load_dotenv and dotenv_values to work with StringIO()) ( @alanjds )( @theskumar )( #78 )","title":"0.8.0"},{"location":"CHANGELOG/#071","text":"Remove hard dependency on iPython ( @theskumar )","title":"0.7.1"},{"location":"CHANGELOG/#070","text":"Add support to override system environment variable via .env. ( @milonimrod ) ( #63 ) Disable \".env not found\" warning by default ( @maxkoryukov ) ( #57 )","title":"0.7.0"},{"location":"CHANGELOG/#065","text":"Add support for special characters \\ . ( @pjona ) ( #60 )","title":"0.6.5"},{"location":"CHANGELOG/#064","text":"Fix issue with single quotes ( @Flimm ) ( #52 )","title":"0.6.4"},{"location":"CHANGELOG/#063","text":"Handle unicode exception in setup.py ( #46 )","title":"0.6.3"},{"location":"CHANGELOG/#062","text":"Fix dotenv list command ( @ticosax ) Add iPython Suport ( @tillahoffmann )","title":"0.6.2"},{"location":"CHANGELOG/#060","text":"Drop support for Python 2.6 Handle escaped charaters and newlines in quoted values. (Thanks @iameugenejo ) Remove any spaces around unquoted key/value. (Thanks @paulochf ) Added POSIX variable expansion. (Thanks @hugochinchilla )","title":"0.6.0"},{"location":"CHANGELOG/#051","text":"Fix find_dotenv - it now start search from the file where this function is called from.","title":"0.5.1"},{"location":"CHANGELOG/#050","text":"Add find_dotenv method that will try to find a .env file. (Thanks @isms )","title":"0.5.0"},{"location":"CHANGELOG/#040","text":"cli: Added -q/--quote option to control the behaviour of quotes around values in .env . (Thanks @hugochinchilla ). Improved test coverage.","title":"0.4.0"},{"location":"CONTRIBUTING/","text":"Contributing All the contributions are welcome! Please open an issue or send us a pull request. This project is currently maintained by Saurabh Kumar and Bertrand Bonnefoy-Claudet and would not have been possible without the support of these awesome people . Executing the tests: $ pip install -r requirements.txt $ pip install -e . $ flake8 $ pytest or with tox installed: $ tox","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All the contributions are welcome! Please open an issue or send us a pull request. This project is currently maintained by Saurabh Kumar and Bertrand Bonnefoy-Claudet and would not have been possible without the support of these awesome people . Executing the tests: $ pip install -r requirements.txt $ pip install -e . $ flake8 $ pytest or with tox installed: $ tox","title":"Contributing"},{"location":"reference/dotenv/","text":"Module dotenv View Source from typing import Any , Optional # noqa from .main import load_dotenv , get_key , set_key , unset_key , find_dotenv , dotenv_values def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython ) def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ): # type: (Optional[str], Optional[str], Optional[str], Optional[str], Optional[str]) -> str \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s ' % quote ) if path : command . append ( '-f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\" %s \"' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () __all__ = [ 'get_cli_string' , 'load_dotenv' , 'dotenv_values' , 'get_key' , 'set_key' , 'unset_key' , 'find_dotenv' , 'load_ipython_extension' ] Functions dotenv_values def dotenv_values ( dotenv_path = None , stream = None , verbose = False , ** kwargs ) View Source def dotenv_values ( dotenv_path = None , stream = None , verbose = False , ** kwargs ) : # type : ( Union [ Text , _PathLike , None ], Optional [ _StringIO ], bool , Union [ None , Text ] ) -> Dict [ Text , Text ] f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , ** kwargs ) . dict () find_dotenv def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ) Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename = ' .env ' , raise_error_if_not_found = False , usecwd = False ) : # type : ( Text , bool , bool ) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found , or an empty string otherwise \"\"\" def _is_interactive () : \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( ' __main__ ' , None , None , fromlist = [ ' __file__ ' ] ) return not hasattr ( main , ' __file__ ' ) if usecwd or _is_interactive () : # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( ' .py ' ) : # in Python2 __file__ extension could be . pyc or . pyo ( this doesn ' t account # for edge case of Python compiled for non - standard extension ) current_file = __file__ . rsplit ( ' . ' , 1 ) [ 0 ] + ' .py ' else : current_file = __file__ while frame . f_code . co_filename == current_file : frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ) : check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ) : return check_path if raise_error_if_not_found : raise IOError ( ' File not found ' ) return '' get_cli_string def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a local or run command. View Source def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) : # type : ( Optional [ str ], Optional [ str ], Optional [ str ], Optional [ str ], Optional [ str ] ) -> str \"\"\" Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a ` local ` or ` run ` command . \"\"\" command = [ ' dotenv ' ] if quote : command . append ( ' -q %s ' % quote ) if path : command . append ( ' -f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( ' \"%s\" ' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () get_key def get_key ( dotenv_path , key_to_get ) Gets the value of a given key from the given .env If the .env path given doesn't exist, fails View Source def get_key ( dotenv_path , key_to_get ) : # type : ( Union [ Text , _PathLike ], Text ) -> Optional [ Text ] \"\"\" Gets the value of a given key from the given . env If the . env path given doesn ' t exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ) . get ( key_to_get ) load_dotenv def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , ** kwargs ) Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : StringIO object with .env content. verbose : whether to output the warnings related to missing .env file etc. Defaults to False . override : where to override the system environment variables with the variables in .env file. Defaults to False . View Source def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , ** kwargs ) : # type : ( Union [ Text , _PathLike , None ], Optional [ _StringIO ], bool , bool , Union [ None , Text ] ) -> bool \"\"\" Parse a .env file and then load all the variables found as environment variables. - * dotenv_path * : absolute or relative path to . env file . - * stream * : ` StringIO ` object with . env content . - * verbose * : whether to output the warnings related to missing . env file etc . Defaults to ` False `. - * override * : where to override the system environment variables with the variables in `. env ` file . Defaults to ` False `. \"\"\" f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , ** kwargs ) . set_as_environment_variables ( override = override ) load_ipython_extension def load_ipython_extension ( ipython ) View Source def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython ) set_key def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = 'always' ) Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \" always \" ) : # type : ( _PathLike , Text , Text , Text ) -> Tuple [ Optional [ bool ], Text , Text ] \"\"\" Adds or Updates a key / value to the given . env If the . env path given doesn ' t exist, fails instead of risking creating an orphan . env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \" ' \" ) . strip ( ' \" ' ) if not os . path . exists ( dotenv_path ) : warnings . warn ( \" can't write to %s - it doesn't exist. \" % dotenv_path ) # type : ignore return None , key_to_set , value_to_set if \" \" in value_to_set : quote_mode = \" always \" line_template = ' {}=\"{}\" \\n ' if quote_mode == \" always \" else ' {}={} \\n ' line_out = line_template . format ( key_to_set , value_to_set ) with rewrite ( dotenv_path ) as ( source , dest ) : replaced = False for mapping in parse_stream ( source ) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set unset_key def unset_key ( dotenv_path , key_to_unset , quote_mode = 'always' ) Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path , key_to_unset , quote_mode = \" always \" ) : # type : ( _PathLike , Text , Text ) -> Tuple [ Optional [ bool ], Text ] \"\"\" Removes a given key from the given . env If the . env path given doesn ' t exist, fails If the given key doesn ' t exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : warnings . warn ( \" can't delete from %s - it doesn't exist. \" % dotenv_path ) # type : ignore return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ) : for mapping in parse_stream ( source ) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original ) if not removed : warnings . warn ( \" key %s not removed from %s - key doesn't exist. \" % ( key_to_unset , dotenv_path )) # type : ignore return None , key_to_unset return removed , key_to_unset","title":"Dotenv"},{"location":"reference/dotenv/#module-dotenv","text":"View Source from typing import Any , Optional # noqa from .main import load_dotenv , get_key , set_key , unset_key , find_dotenv , dotenv_values def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython ) def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ): # type: (Optional[str], Optional[str], Optional[str], Optional[str], Optional[str]) -> str \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s ' % quote ) if path : command . append ( '-f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\" %s \"' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () __all__ = [ 'get_cli_string' , 'load_dotenv' , 'dotenv_values' , 'get_key' , 'set_key' , 'unset_key' , 'find_dotenv' , 'load_ipython_extension' ]","title":"Module dotenv"},{"location":"reference/dotenv/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/#dotenv_values","text":"def dotenv_values ( dotenv_path = None , stream = None , verbose = False , ** kwargs ) View Source def dotenv_values ( dotenv_path = None , stream = None , verbose = False , ** kwargs ) : # type : ( Union [ Text , _PathLike , None ], Optional [ _StringIO ], bool , Union [ None , Text ] ) -> Dict [ Text , Text ] f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , ** kwargs ) . dict ()","title":"dotenv_values"},{"location":"reference/dotenv/#find_dotenv","text":"def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ) Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename = ' .env ' , raise_error_if_not_found = False , usecwd = False ) : # type : ( Text , bool , bool ) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found , or an empty string otherwise \"\"\" def _is_interactive () : \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( ' __main__ ' , None , None , fromlist = [ ' __file__ ' ] ) return not hasattr ( main , ' __file__ ' ) if usecwd or _is_interactive () : # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( ' .py ' ) : # in Python2 __file__ extension could be . pyc or . pyo ( this doesn ' t account # for edge case of Python compiled for non - standard extension ) current_file = __file__ . rsplit ( ' . ' , 1 ) [ 0 ] + ' .py ' else : current_file = __file__ while frame . f_code . co_filename == current_file : frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ) : check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ) : return check_path if raise_error_if_not_found : raise IOError ( ' File not found ' ) return ''","title":"find_dotenv"},{"location":"reference/dotenv/#get_cli_string","text":"def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a local or run command. View Source def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) : # type : ( Optional [ str ], Optional [ str ], Optional [ str ], Optional [ str ], Optional [ str ] ) -> str \"\"\" Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a ` local ` or ` run ` command . \"\"\" command = [ ' dotenv ' ] if quote : command . append ( ' -q %s ' % quote ) if path : command . append ( ' -f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( ' \"%s\" ' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip ()","title":"get_cli_string"},{"location":"reference/dotenv/#get_key","text":"def get_key ( dotenv_path , key_to_get ) Gets the value of a given key from the given .env If the .env path given doesn't exist, fails View Source def get_key ( dotenv_path , key_to_get ) : # type : ( Union [ Text , _PathLike ], Text ) -> Optional [ Text ] \"\"\" Gets the value of a given key from the given . env If the . env path given doesn ' t exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ) . get ( key_to_get )","title":"get_key"},{"location":"reference/dotenv/#load_dotenv","text":"def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , ** kwargs ) Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : StringIO object with .env content. verbose : whether to output the warnings related to missing .env file etc. Defaults to False . override : where to override the system environment variables with the variables in .env file. Defaults to False . View Source def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , ** kwargs ) : # type : ( Union [ Text , _PathLike , None ], Optional [ _StringIO ], bool , bool , Union [ None , Text ] ) -> bool \"\"\" Parse a .env file and then load all the variables found as environment variables. - * dotenv_path * : absolute or relative path to . env file . - * stream * : ` StringIO ` object with . env content . - * verbose * : whether to output the warnings related to missing . env file etc . Defaults to ` False `. - * override * : where to override the system environment variables with the variables in `. env ` file . Defaults to ` False `. \"\"\" f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , ** kwargs ) . set_as_environment_variables ( override = override )","title":"load_dotenv"},{"location":"reference/dotenv/#load_ipython_extension","text":"def load_ipython_extension ( ipython ) View Source def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython )","title":"load_ipython_extension"},{"location":"reference/dotenv/#set_key","text":"def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = 'always' ) Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \" always \" ) : # type : ( _PathLike , Text , Text , Text ) -> Tuple [ Optional [ bool ], Text , Text ] \"\"\" Adds or Updates a key / value to the given . env If the . env path given doesn ' t exist, fails instead of risking creating an orphan . env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \" ' \" ) . strip ( ' \" ' ) if not os . path . exists ( dotenv_path ) : warnings . warn ( \" can't write to %s - it doesn't exist. \" % dotenv_path ) # type : ignore return None , key_to_set , value_to_set if \" \" in value_to_set : quote_mode = \" always \" line_template = ' {}=\"{}\" \\n ' if quote_mode == \" always \" else ' {}={} \\n ' line_out = line_template . format ( key_to_set , value_to_set ) with rewrite ( dotenv_path ) as ( source , dest ) : replaced = False for mapping in parse_stream ( source ) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set","title":"set_key"},{"location":"reference/dotenv/#unset_key","text":"def unset_key ( dotenv_path , key_to_unset , quote_mode = 'always' ) Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path , key_to_unset , quote_mode = \" always \" ) : # type : ( _PathLike , Text , Text ) -> Tuple [ Optional [ bool ], Text ] \"\"\" Removes a given key from the given . env If the . env path given doesn ' t exist, fails If the given key doesn ' t exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : warnings . warn ( \" can't delete from %s - it doesn't exist. \" % dotenv_path ) # type : ignore return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ) : for mapping in parse_stream ( source ) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original ) if not removed : warnings . warn ( \" key %s not removed from %s - key doesn't exist. \" % ( key_to_unset , dotenv_path )) # type : ignore return None , key_to_unset return removed , key_to_unset","title":"unset_key"},{"location":"venv/lib/python3.7/site-packages/Markdown-3.1.1.dist-info/LICENSE/","text":"Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version) All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Python Markdown Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE PYTHON MARKDOWN PROJECT ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ANY CONTRIBUTORS TO THE PYTHON MARKDOWN PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"LICENSE"},{"location":"venv/lib/python3.7/site-packages/pdocs/templates/","text":"The license included in this directory is for HTML5 Boiler Plate . Some of the HTML and CSS used here is derived from that project.","title":"Home"},{"location":"venv/lib/python3.7/site-packages/pep562-1.0.dist-info/LICENSE/","text":"MIT License Copyright (c) 2018 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"venv/lib/python3.7/site-packages/pymdown_extensions-6.1.dist-info/LICENSE/","text":"The MIT License (MIT) (Except where stated below) Copyright (c) 2014 - 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. superfences.py is derived from Python Markdown's fenced_code extension. Fenced Code Extension for Python Markdown ========================================= This extension adds Fenced Code Blocks to Python-Markdown. See https://python-markdown.github.io/extensions/fenced_code_blocks/ for documentation. Original code Copyright 2007-2008 Waylan Limberg . All changes Copyright 2008-2014 The Python Markdown Project License: BSD inlinehilite.py is derived from Python Markdown's codehilite extension. CodeHilite Extension for Python-Markdown ======================================== Adds code/syntax highlighting to standard Python-Markdown code blocks. See https://python-markdown.github.io/extensions/code_hilite/ for documentation. Original code Copyright 2006-2008 Waylan Limberg . All changes Copyright 2008-2014 The Python Markdown Project License: BSD extrarawhtml.py is a literal copy and paste from Python Markdown's extra extension. It basically splits out the raw html markdown parsing into a seprate extension that can be used even if it is not desired to use all of 'extra'. Python-Markdown Extra Extension =============================== See https://python-markdown.github.io/extensions/extra/ for documentation. Copyright The Python Markdown Project License: BSD gemoji_db.py is generated from Gemoji's source code: https://github.com/github/gemoji. Copyright (c) 2013 GitHub, Inc. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. emoji1_db.py is generated from EmojiOne's source code: https://github.com/Ranks/emojione EmojiOne Non-Artwork Applies to the Javascript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above. License: MIT Complete Legal Terms: http://opensource.org/licenses/MIT","title":"LICENSE"}]}