{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-dotenv Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. Getting Started Other Use Cases Load configuration without altering the environment Parse configuration as a stream Load .env files in IPython Command-line Interface File format Multiline values Variable expansion Related Projects Acknowledgements Getting Started pip install python-dotenv If your application takes its configuration from environment variables, like a 12-factor application, launching it in development is not very practical because you have to set those environment variables yourself. To help you with that, you can add Python-dotenv to your application to make it load the configuration from a .env file when it is present (e.g. in development) while remaining configurable via the environment: from dotenv import load_dotenv load_dotenv () # take environment variables from .env. # Code of your application, which uses environment variables (e.g. from `os.environ` or # `os.getenv`) as if they came from the actual environment. By default, load_dotenv doesn't override existing environment variables. To configure the development environment, add a .env in the root directory of your project: . \u251c\u2500\u2500 .env \u2514\u2500\u2500 foo.py The syntax of .env files supported by python-dotenv is similar to that of Bash: # Development settings DOMAIN = example.org ADMIN_EMAIL = admin@ ${ DOMAIN } ROOT_URL = ${ DOMAIN } /app If you use variables in values, ensure they are surrounded with { and } , like ${DOMAIN} , as bare variables such as $DOMAIN are not expanded. You will probably want to add .env to your .gitignore , especially if it contains secrets like a password. See the section \"File format\" below for more information about what you can write in a .env file. Other Use Cases Load configuration without altering the environment The function dotenv_values works more or less the same way as load_dotenv , except it doesn't touch the environment, it just returns a dict with the values parsed from the .env file. from dotenv import dotenv_values config = dotenv_values ( \".env\" ) # config = {\"USER\": \"foo\", \"EMAIL\": \"foo@example.org\"} This notably enables advanced configuration management: import os from dotenv import dotenv_values config = { ** dotenv_values ( \".env.shared\" ), # load shared development variables ** dotenv_values ( \".env.secret\" ), # load sensitive variables ** os . environ , # override loaded values with environment variables } Parse configuration as a stream load_dotenv and dotenv_values accept streams via their stream argument. It is thus possible to load the variables from sources other than the filesystem (e.g. the network). from io import StringIO from dotenv import load_dotenv config = StringIO ( \"USER=foo \\n EMAIL=foo@example.org\" ) load_dotenv ( stream = stream ) Load .env files in IPython You can use dotenv in IPython. By default, it will use find_dotenv to search for a .env file: % load_ext dotenv % dotenv You can also specify a path: % dotenv relative / or / absolute / path / to /. env Optional flags: -o to override existing variables. -v for increased verbosity. Command-line Interface A CLI interface dotenv is also included, which helps you manipulate the .env file without manually opening it. $ pip install \"python-dotenv[cli]\" $ dotenv set USER = foo $ dotenv set EMAIL = foo@example.org $ dotenv list USER = foo EMAIL = foo@example.org $ dotenv run -- python foo.py Run dotenv --help for more information about the options and subcommands. File format The format is not formally specified and still improves over time. That being said, .env files should mostly look like Bash files. Keys can be unquoted or single-quoted. Values can be unquoted, single- or double-quoted. Spaces before and after keys, equal signs, and values are ignored. Values can be followed by a comment. Lines can start with the export directive, which has no effect on their interpretation. Allowed escape sequences: in single-quoted values: \\\\ , \\' in double-quoted values: \\\\ , \\' , \\\" , \\a , \\b , \\f , \\n , \\r , \\t , \\v Multiline values It is possible for single- or double-quoted values to span multiple lines. The following examples are equivalent: FOO = \"first line second line\" FOO = \"first line\\nsecond line\" Variable expansion Python-dotenv can interpolate variables using POSIX variable expansion. With load_dotenv(override=True) or dotenv_values() , the value of a variable is the first of the values defined in the following list: Value of that variable in the .env file. Value of that variable in the environment. Default value, if provided. Empty string. With load_dotenv(override=False) , the value of a variable is the first of the values defined in the following list: Value of that variable in the environment. Value of that variable in the .env file. Default value, if provided. Empty string. Related Projects Honcho - For managing Procfile-based applications. django-dotenv django-environ django-configuration dump-env environs dynaconf Acknowledgements This project is currently maintained by Saurabh Kumar and Bertrand Bonnefoy-Claudet and would not have been possible without the support of these awesome people .","title":"Home"},{"location":"#python-dotenv","text":"Python-dotenv reads key-value pairs from a .env file and can set them as environment variables. It helps in the development of applications following the 12-factor principles. Getting Started Other Use Cases Load configuration without altering the environment Parse configuration as a stream Load .env files in IPython Command-line Interface File format Multiline values Variable expansion Related Projects Acknowledgements","title":"python-dotenv"},{"location":"#getting-started","text":"pip install python-dotenv If your application takes its configuration from environment variables, like a 12-factor application, launching it in development is not very practical because you have to set those environment variables yourself. To help you with that, you can add Python-dotenv to your application to make it load the configuration from a .env file when it is present (e.g. in development) while remaining configurable via the environment: from dotenv import load_dotenv load_dotenv () # take environment variables from .env. # Code of your application, which uses environment variables (e.g. from `os.environ` or # `os.getenv`) as if they came from the actual environment. By default, load_dotenv doesn't override existing environment variables. To configure the development environment, add a .env in the root directory of your project: . \u251c\u2500\u2500 .env \u2514\u2500\u2500 foo.py The syntax of .env files supported by python-dotenv is similar to that of Bash: # Development settings DOMAIN = example.org ADMIN_EMAIL = admin@ ${ DOMAIN } ROOT_URL = ${ DOMAIN } /app If you use variables in values, ensure they are surrounded with { and } , like ${DOMAIN} , as bare variables such as $DOMAIN are not expanded. You will probably want to add .env to your .gitignore , especially if it contains secrets like a password. See the section \"File format\" below for more information about what you can write in a .env file.","title":"Getting Started"},{"location":"#other-use-cases","text":"","title":"Other Use Cases"},{"location":"#load-configuration-without-altering-the-environment","text":"The function dotenv_values works more or less the same way as load_dotenv , except it doesn't touch the environment, it just returns a dict with the values parsed from the .env file. from dotenv import dotenv_values config = dotenv_values ( \".env\" ) # config = {\"USER\": \"foo\", \"EMAIL\": \"foo@example.org\"} This notably enables advanced configuration management: import os from dotenv import dotenv_values config = { ** dotenv_values ( \".env.shared\" ), # load shared development variables ** dotenv_values ( \".env.secret\" ), # load sensitive variables ** os . environ , # override loaded values with environment variables }","title":"Load configuration without altering the environment"},{"location":"#parse-configuration-as-a-stream","text":"load_dotenv and dotenv_values accept streams via their stream argument. It is thus possible to load the variables from sources other than the filesystem (e.g. the network). from io import StringIO from dotenv import load_dotenv config = StringIO ( \"USER=foo \\n EMAIL=foo@example.org\" ) load_dotenv ( stream = stream )","title":"Parse configuration as a stream"},{"location":"#load-env-files-in-ipython","text":"You can use dotenv in IPython. By default, it will use find_dotenv to search for a .env file: % load_ext dotenv % dotenv You can also specify a path: % dotenv relative / or / absolute / path / to /. env Optional flags: -o to override existing variables. -v for increased verbosity.","title":"Load .env files in IPython"},{"location":"#command-line-interface","text":"A CLI interface dotenv is also included, which helps you manipulate the .env file without manually opening it. $ pip install \"python-dotenv[cli]\" $ dotenv set USER = foo $ dotenv set EMAIL = foo@example.org $ dotenv list USER = foo EMAIL = foo@example.org $ dotenv run -- python foo.py Run dotenv --help for more information about the options and subcommands.","title":"Command-line Interface"},{"location":"#file-format","text":"The format is not formally specified and still improves over time. That being said, .env files should mostly look like Bash files. Keys can be unquoted or single-quoted. Values can be unquoted, single- or double-quoted. Spaces before and after keys, equal signs, and values are ignored. Values can be followed by a comment. Lines can start with the export directive, which has no effect on their interpretation. Allowed escape sequences: in single-quoted values: \\\\ , \\' in double-quoted values: \\\\ , \\' , \\\" , \\a , \\b , \\f , \\n , \\r , \\t , \\v","title":"File format"},{"location":"#multiline-values","text":"It is possible for single- or double-quoted values to span multiple lines. The following examples are equivalent: FOO = \"first line second line\" FOO = \"first line\\nsecond line\"","title":"Multiline values"},{"location":"#variable-expansion","text":"Python-dotenv can interpolate variables using POSIX variable expansion. With load_dotenv(override=True) or dotenv_values() , the value of a variable is the first of the values defined in the following list: Value of that variable in the .env file. Value of that variable in the environment. Default value, if provided. Empty string. With load_dotenv(override=False) , the value of a variable is the first of the values defined in the following list: Value of that variable in the environment. Value of that variable in the .env file. Default value, if provided. Empty string.","title":"Variable expansion"},{"location":"#related-projects","text":"Honcho - For managing Procfile-based applications. django-dotenv django-environ django-configuration dump-env environs dynaconf","title":"Related Projects"},{"location":"#acknowledgements","text":"This project is currently maintained by Saurabh Kumar and Bertrand Bonnefoy-Claudet and would not have been possible without the support of these awesome people .","title":"Acknowledgements"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased Fix resolution order in variable expansion with override=False (#? by @bbc2 ). 0.15.0 - 2020-10-28 Added Add --export option to set to make it prepend the binding with export (#270 by @jadutter ). Changed Make set command create the .env file in the current directory if no .env file was found (#270 by @jadutter ). Fixed Fix potentially empty expanded value for duplicate key (#260 by @bbc2 ). Fix import error on Python 3.5.0 and 3.5.1 (#267 by @gongqingkui ). Fix parsing of unquoted values containing several adjacent space or tab characters (#277 by @bbc2 , review by @x-yuri ). 0.14.0 - 2020-07-03 Changed Privilege definition in file over the environment in variable expansion (#256 by @elbehery95 ). Fixed Improve error message for when file isn't found (#245 by @snobu ). Use HTTPS URL in package meta data (#251 by @ekohl ). 0.13.0 - 2020-04-16 Added Add support for a Bash-like default value in variable expansion (#248 by @bbc2 ). 0.12.0 - 2020-02-28 Changed Use current working directory to find .env when bundled by PyInstaller (#213 by @gergelyk ). Fixed Fix escaping of quoted values written by set_key (#236 by @bbc2 ). Fix dotenv run crashing on environment variables without values (#237 by @yannham ). Remove warning when last line is empty (#238 by @bbc2 ). 0.11.0 - 2020-02-07 Added Add interpolate argument to load_dotenv and dotenv_values to disable interpolation (#232 by @ulyssessouza ). Changed Use logging instead of warnings (#231 by @bbc2 ). Fixed Fix installation in non-UTF-8 environments (#225 by @altendky ). Fix PyPI classifiers (#228 by @bbc2 ). 0.10.5 - 2020-01-19 Fixed Fix handling of malformed lines and lines without a value (#222 by @bbc2 ): Don't print warning when key has no value. Reject more malformed lines (e.g. \"A: B\", \"a='b',c\"). Fix handling of lines with just a comment (#224 by @bbc2 ). 0.10.4 - 2020-01-17 Added Make typing optional (#179 by @techalchemy ). Print a warning on malformed line (#211 by @bbc2 ). Support keys without a value (#220 by @ulyssessouza ). 0.10.3 Improve interactive mode detection ( @andrewsmith )( #183 ). Refactor parser to fix parsing inconsistencies ( @bbc2 )( #170 ). Interpret escapes as control characters only in double-quoted strings. Interpret # as start of comment only if preceded by whitespace. 0.10.2 Add type hints and expose them to users ( @qnighy )( #172 ) load_dotenv and dotenv_values now accept an encoding parameter, defaults to None ( @theskumar )( @earlbread )([#161]) Fix str / unicode inconsistency in Python 2: values are always str now. ( @bbc2 )( #121 ) Fix Unicode error in Python 2, introduced in 0.10.0. ( @bbc2 )( #176 ) 0.10.1 Fix parsing of variable without a value ( @asyncee )( @bbc2 )( #158 ) 0.10.0 Add support for UTF-8 in unquoted values ( @bbc2 )( #148 ) Add support for trailing comments ( @bbc2 )( #148 ) Add backslashes support in values ( @bbc2 )( #148 ) Add support for newlines in values ( @bbc2 )( #148 ) Force environment variables to str with Python2 on Windows ( @greyli ) Drop Python 3.3 support ( @greyli ) Fix stderr/-out/-in redirection ( @venthur ) 0.9.0 Add --version parameter to cli ( @venthur ) Enable loading from current directory ( @cjauvin ) Add 'dotenv run' command for calling arbitrary shell script with .env ( @venthur ) 0.8.1 Add tests for docs ( @Flimm ) Make 'cli' support optional. Use pip install python-dotenv[cli] . ( @theskumar ) 0.8.0 set_key and unset_key only modified the affected file instead of parsing and re-writing file, this causes comments and other file entact as it is. Add support for export prefix in the line. Internal refractoring ( @theskumar ) Allow load_dotenv and dotenv_values to work with StringIO()) ( @alanjds )( @theskumar )( #78 ) 0.7.1 Remove hard dependency on iPython ( @theskumar ) 0.7.0 Add support to override system environment variable via .env. ( @milonimrod ) ( #63 ) Disable \".env not found\" warning by default ( @maxkoryukov ) ( #57 ) 0.6.5 Add support for special characters \\ . ( @pjona ) ( #60 ) 0.6.4 Fix issue with single quotes ( @Flimm ) ( #52 ) 0.6.3 Handle unicode exception in setup.py ( #46 ) 0.6.2 Fix dotenv list command ( @ticosax ) Add iPython Suport ( @tillahoffmann ) 0.6.0 Drop support for Python 2.6 Handle escaped charaters and newlines in quoted values. (Thanks @iameugenejo ) Remove any spaces around unquoted key/value. (Thanks @paulochf ) Added POSIX variable expansion. (Thanks @hugochinchilla ) 0.5.1 Fix find_dotenv - it now start search from the file where this function is called from. 0.5.0 Add find_dotenv method that will try to find a .env file. (Thanks @isms ) 0.4.0 cli: Added -q/--quote option to control the behaviour of quotes around values in .env . (Thanks @hugochinchilla ). Improved test coverage.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Fix resolution order in variable expansion with override=False (#? by @bbc2 ).","title":"Unreleased"},{"location":"CHANGELOG/#0150-2020-10-28","text":"","title":"0.15.0 - 2020-10-28"},{"location":"CHANGELOG/#added","text":"Add --export option to set to make it prepend the binding with export (#270 by @jadutter ).","title":"Added"},{"location":"CHANGELOG/#changed","text":"Make set command create the .env file in the current directory if no .env file was found (#270 by @jadutter ).","title":"Changed"},{"location":"CHANGELOG/#fixed","text":"Fix potentially empty expanded value for duplicate key (#260 by @bbc2 ). Fix import error on Python 3.5.0 and 3.5.1 (#267 by @gongqingkui ). Fix parsing of unquoted values containing several adjacent space or tab characters (#277 by @bbc2 , review by @x-yuri ).","title":"Fixed"},{"location":"CHANGELOG/#0140-2020-07-03","text":"","title":"0.14.0 - 2020-07-03"},{"location":"CHANGELOG/#changed_1","text":"Privilege definition in file over the environment in variable expansion (#256 by @elbehery95 ).","title":"Changed"},{"location":"CHANGELOG/#fixed_1","text":"Improve error message for when file isn't found (#245 by @snobu ). Use HTTPS URL in package meta data (#251 by @ekohl ).","title":"Fixed"},{"location":"CHANGELOG/#0130-2020-04-16","text":"","title":"0.13.0 - 2020-04-16"},{"location":"CHANGELOG/#added_1","text":"Add support for a Bash-like default value in variable expansion (#248 by @bbc2 ).","title":"Added"},{"location":"CHANGELOG/#0120-2020-02-28","text":"","title":"0.12.0 - 2020-02-28"},{"location":"CHANGELOG/#changed_2","text":"Use current working directory to find .env when bundled by PyInstaller (#213 by @gergelyk ).","title":"Changed"},{"location":"CHANGELOG/#fixed_2","text":"Fix escaping of quoted values written by set_key (#236 by @bbc2 ). Fix dotenv run crashing on environment variables without values (#237 by @yannham ). Remove warning when last line is empty (#238 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0110-2020-02-07","text":"","title":"0.11.0 - 2020-02-07"},{"location":"CHANGELOG/#added_2","text":"Add interpolate argument to load_dotenv and dotenv_values to disable interpolation (#232 by @ulyssessouza ).","title":"Added"},{"location":"CHANGELOG/#changed_3","text":"Use logging instead of warnings (#231 by @bbc2 ).","title":"Changed"},{"location":"CHANGELOG/#fixed_3","text":"Fix installation in non-UTF-8 environments (#225 by @altendky ). Fix PyPI classifiers (#228 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0105-2020-01-19","text":"","title":"0.10.5 - 2020-01-19"},{"location":"CHANGELOG/#fixed_4","text":"Fix handling of malformed lines and lines without a value (#222 by @bbc2 ): Don't print warning when key has no value. Reject more malformed lines (e.g. \"A: B\", \"a='b',c\"). Fix handling of lines with just a comment (#224 by @bbc2 ).","title":"Fixed"},{"location":"CHANGELOG/#0104-2020-01-17","text":"","title":"0.10.4 - 2020-01-17"},{"location":"CHANGELOG/#added_3","text":"Make typing optional (#179 by @techalchemy ). Print a warning on malformed line (#211 by @bbc2 ). Support keys without a value (#220 by @ulyssessouza ).","title":"Added"},{"location":"CHANGELOG/#0103","text":"Improve interactive mode detection ( @andrewsmith )( #183 ). Refactor parser to fix parsing inconsistencies ( @bbc2 )( #170 ). Interpret escapes as control characters only in double-quoted strings. Interpret # as start of comment only if preceded by whitespace.","title":"0.10.3"},{"location":"CHANGELOG/#0102","text":"Add type hints and expose them to users ( @qnighy )( #172 ) load_dotenv and dotenv_values now accept an encoding parameter, defaults to None ( @theskumar )( @earlbread )([#161]) Fix str / unicode inconsistency in Python 2: values are always str now. ( @bbc2 )( #121 ) Fix Unicode error in Python 2, introduced in 0.10.0. ( @bbc2 )( #176 )","title":"0.10.2"},{"location":"CHANGELOG/#0101","text":"Fix parsing of variable without a value ( @asyncee )( @bbc2 )( #158 )","title":"0.10.1"},{"location":"CHANGELOG/#0100","text":"Add support for UTF-8 in unquoted values ( @bbc2 )( #148 ) Add support for trailing comments ( @bbc2 )( #148 ) Add backslashes support in values ( @bbc2 )( #148 ) Add support for newlines in values ( @bbc2 )( #148 ) Force environment variables to str with Python2 on Windows ( @greyli ) Drop Python 3.3 support ( @greyli ) Fix stderr/-out/-in redirection ( @venthur )","title":"0.10.0"},{"location":"CHANGELOG/#090","text":"Add --version parameter to cli ( @venthur ) Enable loading from current directory ( @cjauvin ) Add 'dotenv run' command for calling arbitrary shell script with .env ( @venthur )","title":"0.9.0"},{"location":"CHANGELOG/#081","text":"Add tests for docs ( @Flimm ) Make 'cli' support optional. Use pip install python-dotenv[cli] . ( @theskumar )","title":"0.8.1"},{"location":"CHANGELOG/#080","text":"set_key and unset_key only modified the affected file instead of parsing and re-writing file, this causes comments and other file entact as it is. Add support for export prefix in the line. Internal refractoring ( @theskumar ) Allow load_dotenv and dotenv_values to work with StringIO()) ( @alanjds )( @theskumar )( #78 )","title":"0.8.0"},{"location":"CHANGELOG/#071","text":"Remove hard dependency on iPython ( @theskumar )","title":"0.7.1"},{"location":"CHANGELOG/#070","text":"Add support to override system environment variable via .env. ( @milonimrod ) ( #63 ) Disable \".env not found\" warning by default ( @maxkoryukov ) ( #57 )","title":"0.7.0"},{"location":"CHANGELOG/#065","text":"Add support for special characters \\ . ( @pjona ) ( #60 )","title":"0.6.5"},{"location":"CHANGELOG/#064","text":"Fix issue with single quotes ( @Flimm ) ( #52 )","title":"0.6.4"},{"location":"CHANGELOG/#063","text":"Handle unicode exception in setup.py ( #46 )","title":"0.6.3"},{"location":"CHANGELOG/#062","text":"Fix dotenv list command ( @ticosax ) Add iPython Suport ( @tillahoffmann )","title":"0.6.2"},{"location":"CHANGELOG/#060","text":"Drop support for Python 2.6 Handle escaped charaters and newlines in quoted values. (Thanks @iameugenejo ) Remove any spaces around unquoted key/value. (Thanks @paulochf ) Added POSIX variable expansion. (Thanks @hugochinchilla )","title":"0.6.0"},{"location":"CHANGELOG/#051","text":"Fix find_dotenv - it now start search from the file where this function is called from.","title":"0.5.1"},{"location":"CHANGELOG/#050","text":"Add find_dotenv method that will try to find a .env file. (Thanks @isms )","title":"0.5.0"},{"location":"CHANGELOG/#040","text":"cli: Added -q/--quote option to control the behaviour of quotes around values in .env . (Thanks @hugochinchilla ). Improved test coverage.","title":"0.4.0"},{"location":"CONTRIBUTING/","text":"Contributing All the contributions are welcome! Please open an issue or send us a pull request. Executing the tests: $ pip install -r requirements.txt $ pip install -e . $ flake8 $ pytest or with tox installed: $ tox","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All the contributions are welcome! Please open an issue or send us a pull request. Executing the tests: $ pip install -r requirements.txt $ pip install -e . $ flake8 $ pytest or with tox installed: $ tox","title":"Contributing"},{"location":"reference/dotenv/","text":"Module dotenv View Source from .compat import IS_TYPE_CHECKING from .main import load_dotenv , get_key , set_key , unset_key , find_dotenv , dotenv_values if IS_TYPE_CHECKING : from typing import Any , Optional def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython ) def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ): # type: (Optional[str], Optional[str], Optional[str], Optional[str], Optional[str]) -> str \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s ' % quote ) if path : command . append ( '-f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\" %s \"' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () __all__ = [ 'get_cli_string' , 'load_dotenv' , 'dotenv_values' , 'get_key' , 'set_key' , 'unset_key' , 'find_dotenv' , 'load_ipython_extension' ] Sub-modules dotenv.cli dotenv.compat dotenv.ipython dotenv.main dotenv.parser dotenv.variables dotenv.version Functions dotenv_values def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) View Source def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) : # type : ( Union [ Text, _PathLike, None ] , Optional [ _StringIO ] , bool , bool , Union [ None, Text ] ) -> Dict [ Text, Optional[Text ] ] # noqa : E501 f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , interpolate = interpolate , override = True , ** kwargs ). dict () find_dotenv def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ) Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ): # type : ( Text , bool , bool ) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( '.py' ): # in Python2 __file__ extension could be . pyc or . pyo ( this doesn 't account # for edge case of Python compiled for non-standard extension) current_file = __file__.rsplit(' . ', 1)[0] + ' . py ' else: current_file = __file__ while frame.f_code.co_filename == current_file: assert frame.f_back is not None frame = frame.f_back frame_filename = frame.f_code.co_filename path = os.path.dirname(os.path.abspath(frame_filename)) for dirname in _walk_to_root(path): check_path = os.path.join(dirname, filename) if os.path.isfile(check_path): return check_path if raise_error_if_not_found: raise IOError(' File not found ') return ' ' get_cli_string def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a local or run command. View Source def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) : # type : ( Optional [ str ] , Optional [ str ] , Optional [ str ] , Optional [ str ] , Optional [ str ] ) -> str \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s' % quote ) if path : command . append ( '-f %s' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\"%s\"' % value ) else : command . append ( value ) return ' ' . join ( command ). strip () get_key def get_key ( dotenv_path , key_to_get ) Gets the value of a given key from the given .env If the .env path given doesn't exist, fails View Source def get_key ( dotenv_path , key_to_get ) : # type : ( Union [ Text, _PathLike ] , Text ) -> Optional [ Text ] \"\"\" Gets the value of a given key from the given .env If the .env path given doesn't exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ). get ( key_to_get ) load_dotenv def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ) Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : StringIO object with .env content. verbose : whether to output the warnings related to missing .env file etc. Defaults to False . override : where to override the system environment variables with the variables in .env file. Defaults to False . View Source def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, bool, Union[None, Text]) -> bool \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: `StringIO` object with .env content. - *verbose*: whether to output the warnings related to missing .env file etc. Defaults to `False`. - *override*: where to override the system environment variables with the variables in `.env` file. Defaults to `False`. \"\"\" f = dotenv_path or stream or find_dotenv () dotenv = DotEnv ( f , verbose = verbose , interpolate = interpolate , override = override , ** kwargs ) return dotenv . set_as_environment_variables () load_ipython_extension def load_ipython_extension ( ipython ) View Source def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython ) set_key def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = 'always' , export = False ) Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \"always\" , export = False ) : # type : ( _PathLike , Text , Text , Text , bool ) -> Tuple [ Optional[bool ] , Text , Text ] \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \"'\" ). strip ( '\"' ) if \" \" in value_to_set : quote_mode = \"always\" if quote_mode == \"always\" : value_out = '\"{}\"' . format ( value_to_set . replace ( '\"' , '\\\\\"' )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path ) as ( source , dest ) : replaced = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set unset_key def unset_key ( dotenv_path , key_to_unset , quote_mode = 'always' ) Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path , key_to_unset , quote_mode = \"always\" ) : # type : ( _PathLike , Text , Text ) -> Tuple [ Optional[bool ] , Text ] \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset","title":"Index"},{"location":"reference/dotenv/#module-dotenv","text":"View Source from .compat import IS_TYPE_CHECKING from .main import load_dotenv , get_key , set_key , unset_key , find_dotenv , dotenv_values if IS_TYPE_CHECKING : from typing import Any , Optional def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython ) def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ): # type: (Optional[str], Optional[str], Optional[str], Optional[str], Optional[str]) -> str \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s ' % quote ) if path : command . append ( '-f %s ' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\" %s \"' % value ) else : command . append ( value ) return ' ' . join ( command ) . strip () __all__ = [ 'get_cli_string' , 'load_dotenv' , 'dotenv_values' , 'get_key' , 'set_key' , 'unset_key' , 'find_dotenv' , 'load_ipython_extension' ]","title":"Module dotenv"},{"location":"reference/dotenv/#sub-modules","text":"dotenv.cli dotenv.compat dotenv.ipython dotenv.main dotenv.parser dotenv.variables dotenv.version","title":"Sub-modules"},{"location":"reference/dotenv/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/#dotenv_values","text":"def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) View Source def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) : # type : ( Union [ Text, _PathLike, None ] , Optional [ _StringIO ] , bool , bool , Union [ None, Text ] ) -> Dict [ Text, Optional[Text ] ] # noqa : E501 f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , interpolate = interpolate , override = True , ** kwargs ). dict ()","title":"dotenv_values"},{"location":"reference/dotenv/#find_dotenv","text":"def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ) Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ): # type : ( Text , bool , bool ) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( '.py' ): # in Python2 __file__ extension could be . pyc or . pyo ( this doesn 't account # for edge case of Python compiled for non-standard extension) current_file = __file__.rsplit(' . ', 1)[0] + ' . py ' else: current_file = __file__ while frame.f_code.co_filename == current_file: assert frame.f_back is not None frame = frame.f_back frame_filename = frame.f_code.co_filename path = os.path.dirname(os.path.abspath(frame_filename)) for dirname in _walk_to_root(path): check_path = os.path.join(dirname, filename) if os.path.isfile(check_path): return check_path if raise_error_if_not_found: raise IOError(' File not found ') return ' '","title":"find_dotenv"},{"location":"reference/dotenv/#get_cli_string","text":"def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a local or run command. View Source def get_cli_string ( path = None , action = None , key = None , value = None , quote = None ) : # type : ( Optional [ str ] , Optional [ str ] , Optional [ str ] , Optional [ str ] , Optional [ str ] ) -> str \"\"\"Returns a string suitable for running as a shell script. Useful for converting a arguments passed to a fabric task to be passed to a `local` or `run` command. \"\"\" command = [ 'dotenv' ] if quote : command . append ( '-q %s' % quote ) if path : command . append ( '-f %s' % path ) if action : command . append ( action ) if key : command . append ( key ) if value : if ' ' in value : command . append ( '\"%s\"' % value ) else : command . append ( value ) return ' ' . join ( command ). strip ()","title":"get_cli_string"},{"location":"reference/dotenv/#get_key","text":"def get_key ( dotenv_path , key_to_get ) Gets the value of a given key from the given .env If the .env path given doesn't exist, fails View Source def get_key ( dotenv_path , key_to_get ) : # type : ( Union [ Text, _PathLike ] , Text ) -> Optional [ Text ] \"\"\" Gets the value of a given key from the given .env If the .env path given doesn't exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ). get ( key_to_get )","title":"get_key"},{"location":"reference/dotenv/#load_dotenv","text":"def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ) Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : StringIO object with .env content. verbose : whether to output the warnings related to missing .env file etc. Defaults to False . override : where to override the system environment variables with the variables in .env file. Defaults to False . View Source def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, bool, Union[None, Text]) -> bool \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: `StringIO` object with .env content. - *verbose*: whether to output the warnings related to missing .env file etc. Defaults to `False`. - *override*: where to override the system environment variables with the variables in `.env` file. Defaults to `False`. \"\"\" f = dotenv_path or stream or find_dotenv () dotenv = DotEnv ( f , verbose = verbose , interpolate = interpolate , override = override , ** kwargs ) return dotenv . set_as_environment_variables ()","title":"load_dotenv"},{"location":"reference/dotenv/#load_ipython_extension","text":"def load_ipython_extension ( ipython ) View Source def load_ipython_extension ( ipython ): # type: (Any) -> None from .ipython import load_ipython_extension load_ipython_extension ( ipython )","title":"load_ipython_extension"},{"location":"reference/dotenv/#set_key","text":"def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = 'always' , export = False ) Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \"always\" , export = False ) : # type : ( _PathLike , Text , Text , Text , bool ) -> Tuple [ Optional[bool ] , Text , Text ] \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \"'\" ). strip ( '\"' ) if \" \" in value_to_set : quote_mode = \"always\" if quote_mode == \"always\" : value_out = '\"{}\"' . format ( value_to_set . replace ( '\"' , '\\\\\"' )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path ) as ( source , dest ) : replaced = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set","title":"set_key"},{"location":"reference/dotenv/#unset_key","text":"def unset_key ( dotenv_path , key_to_unset , quote_mode = 'always' ) Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path , key_to_unset , quote_mode = \"always\" ) : # type : ( _PathLike , Text , Text ) -> Tuple [ Optional[bool ] , Text ] \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset","title":"unset_key"},{"location":"reference/dotenv/cli/","text":"Module dotenv.cli View Source import os import sys from subprocess import Popen try : import click except ImportError : sys . stderr . write ( 'It seems python-dotenv is not installed with cli option. \\n ' 'Run pip install \"python-dotenv[cli]\" to fix this.' ) sys . exit ( 1 ) from .compat import IS_TYPE_CHECKING , to_env from .main import dotenv_values , get_key , set_key , unset_key from .version import __version__ if IS_TYPE_CHECKING : from typing import Any , List , Dict @click.group () @click.option ( '-f' , '--file' , default = os . path . join ( os . getcwd (), '.env' ), type = click . Path ( file_okay = True ), help = \"Location of the .env file, defaults to .env file in current working directory.\" ) @click.option ( '-q' , '--quote' , default = 'always' , type = click . Choice ([ 'always' , 'never' , 'auto' ]), help = \"Whether to quote or not the variable values. Default mode is always. This does not affect parsing.\" ) @click.option ( '-e' , '--export' , default = False , type = click . BOOL , help = \"Whether to write the dot file as an executable bash script.\" ) @click.version_option ( version = __version__ ) @click.pass_context def cli ( ctx , file , quote , export ): # type: (click.Context, Any, Any, Any) -> None '''This script is used to set, get or unset values from a .env file.''' ctx . obj = {} ctx . obj [ 'QUOTE' ] = quote ctx . obj [ 'EXPORT' ] = export ctx . obj [ 'FILE' ] = file @cli.command () @click.pass_context def list ( ctx ): # type: (click.Context) -> None '''Display all the stored key/value.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = dotenv_values ( file ) for k , v in dotenv_as_dict . items (): click . echo ( ' %s = %s ' % ( k , v )) @cli.command () @click.pass_context @click.argument ( 'key' , required = True ) @click.argument ( 'value' , required = True ) def set ( ctx , key , value ): # type: (click.Context, Any, Any) -> None '''Store the given key/value.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] export = ctx . obj [ 'EXPORT' ] success , key , value = set_key ( file , key , value , quote , export ) if success : click . echo ( ' %s = %s ' % ( key , value )) else : exit ( 1 ) @cli.command () @click.pass_context @click.argument ( 'key' , required = True ) def get ( ctx , key ): # type: (click.Context, Any) -> None '''Retrieve the value for the given key.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) stored_value = get_key ( file , key ) if stored_value : click . echo ( ' %s = %s ' % ( key , stored_value )) else : exit ( 1 ) @cli.command () @click.pass_context @click.argument ( 'key' , required = True ) def unset ( ctx , key ): # type: (click.Context, Any) -> None '''Removes the given key.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] success , key = unset_key ( file , key , quote ) if success : click . echo ( \"Successfully removed %s \" % key ) else : exit ( 1 ) @cli.command ( context_settings = { 'ignore_unknown_options' : True }) @click.pass_context @click.argument ( 'commandline' , nargs =- 1 , type = click . UNPROCESSED ) def run ( ctx , commandline ): # type: (click.Context, List[str]) -> None \"\"\"Run command with environment variables present.\"\"\" file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Invalid value for \\' -f \\' \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = { to_env ( k ): to_env ( v ) for ( k , v ) in dotenv_values ( file ) . items () if v is not None } if not commandline : click . echo ( 'No command given.' ) exit ( 1 ) ret = run_command ( commandline , dotenv_as_dict ) exit ( ret ) def run_command ( command , env ): # type: (List[str], Dict[str, str]) -> int \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode if __name__ == \"__main__\" : cli () Variables IS_TYPE_CHECKING Functions run_command def run_command ( command , env ) Run command in sub process. Runs the command in a sub process with the variables from env added in the current environment variables. Parameters command: List[str] The command and it's parameters env: Dict The additional environment variables Returns int The return code of the command View Source def run_command ( command , env ): # type: (List[str], Dict[str, str]) -> int \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode","title":"CLI"},{"location":"reference/dotenv/cli/#module-dotenvcli","text":"View Source import os import sys from subprocess import Popen try : import click except ImportError : sys . stderr . write ( 'It seems python-dotenv is not installed with cli option. \\n ' 'Run pip install \"python-dotenv[cli]\" to fix this.' ) sys . exit ( 1 ) from .compat import IS_TYPE_CHECKING , to_env from .main import dotenv_values , get_key , set_key , unset_key from .version import __version__ if IS_TYPE_CHECKING : from typing import Any , List , Dict @click.group () @click.option ( '-f' , '--file' , default = os . path . join ( os . getcwd (), '.env' ), type = click . Path ( file_okay = True ), help = \"Location of the .env file, defaults to .env file in current working directory.\" ) @click.option ( '-q' , '--quote' , default = 'always' , type = click . Choice ([ 'always' , 'never' , 'auto' ]), help = \"Whether to quote or not the variable values. Default mode is always. This does not affect parsing.\" ) @click.option ( '-e' , '--export' , default = False , type = click . BOOL , help = \"Whether to write the dot file as an executable bash script.\" ) @click.version_option ( version = __version__ ) @click.pass_context def cli ( ctx , file , quote , export ): # type: (click.Context, Any, Any, Any) -> None '''This script is used to set, get or unset values from a .env file.''' ctx . obj = {} ctx . obj [ 'QUOTE' ] = quote ctx . obj [ 'EXPORT' ] = export ctx . obj [ 'FILE' ] = file @cli.command () @click.pass_context def list ( ctx ): # type: (click.Context) -> None '''Display all the stored key/value.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = dotenv_values ( file ) for k , v in dotenv_as_dict . items (): click . echo ( ' %s = %s ' % ( k , v )) @cli.command () @click.pass_context @click.argument ( 'key' , required = True ) @click.argument ( 'value' , required = True ) def set ( ctx , key , value ): # type: (click.Context, Any, Any) -> None '''Store the given key/value.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] export = ctx . obj [ 'EXPORT' ] success , key , value = set_key ( file , key , value , quote , export ) if success : click . echo ( ' %s = %s ' % ( key , value )) else : exit ( 1 ) @cli.command () @click.pass_context @click.argument ( 'key' , required = True ) def get ( ctx , key ): # type: (click.Context, Any) -> None '''Retrieve the value for the given key.''' file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Path \" %s \" does not exist.' % ( file ), ctx = ctx ) stored_value = get_key ( file , key ) if stored_value : click . echo ( ' %s = %s ' % ( key , stored_value )) else : exit ( 1 ) @cli.command () @click.pass_context @click.argument ( 'key' , required = True ) def unset ( ctx , key ): # type: (click.Context, Any) -> None '''Removes the given key.''' file = ctx . obj [ 'FILE' ] quote = ctx . obj [ 'QUOTE' ] success , key = unset_key ( file , key , quote ) if success : click . echo ( \"Successfully removed %s \" % key ) else : exit ( 1 ) @cli.command ( context_settings = { 'ignore_unknown_options' : True }) @click.pass_context @click.argument ( 'commandline' , nargs =- 1 , type = click . UNPROCESSED ) def run ( ctx , commandline ): # type: (click.Context, List[str]) -> None \"\"\"Run command with environment variables present.\"\"\" file = ctx . obj [ 'FILE' ] if not os . path . isfile ( file ): raise click . BadParameter ( 'Invalid value for \\' -f \\' \" %s \" does not exist.' % ( file ), ctx = ctx ) dotenv_as_dict = { to_env ( k ): to_env ( v ) for ( k , v ) in dotenv_values ( file ) . items () if v is not None } if not commandline : click . echo ( 'No command given.' ) exit ( 1 ) ret = run_command ( commandline , dotenv_as_dict ) exit ( ret ) def run_command ( command , env ): # type: (List[str], Dict[str, str]) -> int \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode if __name__ == \"__main__\" : cli ()","title":"Module dotenv.cli"},{"location":"reference/dotenv/cli/#variables","text":"IS_TYPE_CHECKING","title":"Variables"},{"location":"reference/dotenv/cli/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/cli/#run_command","text":"def run_command ( command , env ) Run command in sub process. Runs the command in a sub process with the variables from env added in the current environment variables.","title":"run_command"},{"location":"reference/dotenv/cli/#parameters","text":"command: List[str] The command and it's parameters env: Dict The additional environment variables","title":"Parameters"},{"location":"reference/dotenv/cli/#returns","text":"int The return code of the command View Source def run_command ( command , env ): # type: (List[str], Dict[str, str]) -> int \"\"\"Run command in sub process. Runs the command in a sub process with the variables from `env` added in the current environment variables. Parameters ---------- command: List[str] The command and it's parameters env: Dict The additional environment variables Returns ------- int The return code of the command \"\"\" # copy the current environment variables and add the vales from # `env` cmd_env = os . environ . copy () cmd_env . update ( env ) p = Popen ( command , universal_newlines = True , bufsize = 0 , shell = False , env = cmd_env ) _ , _ = p . communicate () return p . returncode","title":"Returns"},{"location":"reference/dotenv/compat/","text":"Module dotenv.compat View Source import sys PY2 = sys . version_info [ 0 ] == 2 # type: bool if PY2 : from StringIO import StringIO # noqa else : from io import StringIO # noqa def is_type_checking (): # type: () -> bool try : from typing import TYPE_CHECKING except ImportError : return False return TYPE_CHECKING IS_TYPE_CHECKING = is_type_checking () if IS_TYPE_CHECKING : from typing import Text def to_env ( text ): # type: (Text) -> str \"\"\" Encode a string the same way whether it comes from the environment or a `.env` file. \"\"\" if PY2 : return text . encode ( sys . getfilesystemencoding () or \"utf-8\" ) else : return text def to_text ( string ): # type: (str) -> Text \"\"\" Make a string Unicode if it isn't already. This is useful for defining raw unicode strings because `ur\"foo\"` isn't valid in Python 3. \"\"\" if PY2 : return string . decode ( \"utf-8\" ) else : return string Variables IS_TYPE_CHECKING PY2 Functions is_type_checking def is_type_checking ( ) View Source def is_type_checking (): # type: () -> bool try : from typing import TYPE_CHECKING except ImportError : return False return TYPE_CHECKING to_env def to_env ( text ) Encode a string the same way whether it comes from the environment or a .env file. View Source def to_env ( text ): # type : ( Text ) -> str \"\"\" Encode a string the same way whether it comes from the environment or a `.env` file. \"\"\" if PY2 : return text . encode ( sys . getfilesystemencoding () or \"utf-8\" ) else : return text to_text def to_text ( string ) Make a string Unicode if it isn't already. This is useful for defining raw unicode strings because ur\"foo\" isn't valid in Python 3. View Source def to_text ( string ): # type : ( str ) -> Text \"\"\" Make a string Unicode if it isn't already. This is useful for defining raw unicode strings because `ur\" foo \"` isn't valid in Python 3. \"\"\" if PY2 : return string . decode ( \"utf-8\" ) else : return string","title":"Compat"},{"location":"reference/dotenv/compat/#module-dotenvcompat","text":"View Source import sys PY2 = sys . version_info [ 0 ] == 2 # type: bool if PY2 : from StringIO import StringIO # noqa else : from io import StringIO # noqa def is_type_checking (): # type: () -> bool try : from typing import TYPE_CHECKING except ImportError : return False return TYPE_CHECKING IS_TYPE_CHECKING = is_type_checking () if IS_TYPE_CHECKING : from typing import Text def to_env ( text ): # type: (Text) -> str \"\"\" Encode a string the same way whether it comes from the environment or a `.env` file. \"\"\" if PY2 : return text . encode ( sys . getfilesystemencoding () or \"utf-8\" ) else : return text def to_text ( string ): # type: (str) -> Text \"\"\" Make a string Unicode if it isn't already. This is useful for defining raw unicode strings because `ur\"foo\"` isn't valid in Python 3. \"\"\" if PY2 : return string . decode ( \"utf-8\" ) else : return string","title":"Module dotenv.compat"},{"location":"reference/dotenv/compat/#variables","text":"IS_TYPE_CHECKING PY2","title":"Variables"},{"location":"reference/dotenv/compat/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/compat/#is_type_checking","text":"def is_type_checking ( ) View Source def is_type_checking (): # type: () -> bool try : from typing import TYPE_CHECKING except ImportError : return False return TYPE_CHECKING","title":"is_type_checking"},{"location":"reference/dotenv/compat/#to_env","text":"def to_env ( text ) Encode a string the same way whether it comes from the environment or a .env file. View Source def to_env ( text ): # type : ( Text ) -> str \"\"\" Encode a string the same way whether it comes from the environment or a `.env` file. \"\"\" if PY2 : return text . encode ( sys . getfilesystemencoding () or \"utf-8\" ) else : return text","title":"to_env"},{"location":"reference/dotenv/compat/#to_text","text":"def to_text ( string ) Make a string Unicode if it isn't already. This is useful for defining raw unicode strings because ur\"foo\" isn't valid in Python 3. View Source def to_text ( string ): # type : ( str ) -> Text \"\"\" Make a string Unicode if it isn't already. This is useful for defining raw unicode strings because `ur\" foo \"` isn't valid in Python 3. \"\"\" if PY2 : return string . decode ( \"utf-8\" ) else : return string","title":"to_text"},{"location":"reference/dotenv/ipython/","text":"Module dotenv.ipython View Source from __future__ import print_function from IPython.core.magic import Magics , line_magic , magics_class # type: ignore from IPython.core.magic_arguments import ( argument , magic_arguments , # type: ignore parse_argstring ) # type: ignore from .main import find_dotenv , load_dotenv @magics_class class IPythonDotEnv ( Magics ): @magic_arguments () @argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv ) Functions load_ipython_extension def load_ipython_extension ( ipython ) Register the %dotenv magic. View Source def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv ) Classes IPythonDotEnv class IPythonDotEnv ( shell = None , ** kwargs ) Base class for implementing magic functions. Shell functions which can be reached as %function_name. All magic functions should accept a string, which they can parse for their own needs. This can make some functions easier to type, eg %cd ../ vs. %cd(\"../\") Classes providing magic functions need to subclass this class, and they MUST: Use the method decorators @line_magic and @cell_magic to decorate individual methods as magic functions, AND Use the class decorator @magics_class to ensure that the magic methods are properly registered at the instance level upon instance initialization. See :mod: magic_functions for examples of actual implementation classes. View Source @ magics_class class IPythonDotEnv ( Magics ): @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) Ancestors (in MRO) IPython.core.magic.Magics traitlets.config.configurable.Configurable traitlets.traitlets.HasTraits traitlets.traitlets.HasDescriptors Class variables config magics options_table parent registered shell Static methods class_config_rst_doc def class_config_rst_doc ( ) Generate rST documentation for this class' config options. Excludes traits defined on parent classes. View Source @ classmethod def class_config_rst_doc ( cls ): \"\"\"Generate rST documentation for this class' config options. Excludes traits defined on parent classes. \"\"\" lines = [] classname = cls . __name__ for k , trait in sorted ( cls . class_traits ( config = True ) . items ()): ttype = trait . __class__ . __name__ termline = classname + '.' + trait . name # Choices or type if 'Enum' in ttype : # include Enum choices termline += ' : ' + trait . info_rst () else : termline += ' : ' + ttype lines . append ( termline ) # Default value try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [: 61 ] + '...' # Double up backslashes, so they get to the rendered docs dvr = dvr . replace ( ' \\\\ n' , ' \\\\\\\\ n' ) lines . append ( indent ( 'Default: `` %s ``' % dvr , 4 )) lines . append ( '' ) help = trait . help or 'No description' lines . append ( indent ( dedent ( help ), 4 )) # Blank line lines . append ( '' ) return ' \\n ' . join ( lines ) class_config_section def class_config_section ( classes = None ) Get the config section for this class. Parameters classes : list, optional The list of other classes in the config file. Used to reduce redundant information. View Source @classmethod def class_config_section ( cls , classes = None ) : \"\"\"Get the config section for this class. Parameters ---------- classes : list, optional The list of other classes in the config file. Used to reduce redundant information. \"\"\" def c ( s ) : \"\"\"return a commented, wrapped block.\"\"\" s = '\\n\\n' . join ( wrap_paragraphs ( s , 78 )) return '## ' + s . replace ( '\\n' , '\\n# ' ) # section header breaker = '#' + '-' * 78 parent_classes = ', ' . join ( p . __name__ for p in cls . __bases__ if issubclass ( p , Configurable ) ) s = \"# %s(%s) configuration\" % ( cls . __name__ , parent_classes ) lines = [ breaker, s, breaker ] # get the description trait desc = cls . class_traits (). get ( 'description' ) if desc : desc = desc . default_value if not desc : # no description from trait , use __doc__ desc = getattr ( cls , '__doc__' , '' ) if desc : lines . append ( c ( desc )) lines . append ( '' ) for name , trait in sorted ( cls . class_traits ( config = True ). items ()) : default_repr = trait . default_value_repr () if classes : defining_class = cls . _defining_class ( trait , classes ) else : defining_class = cls if defining_class is cls : # cls owns the trait , show full help if trait . help : lines . append ( c ( trait . help )) if 'Enum' in type ( trait ). __name__ : # include Enum choices lines . append ( '# Choices: %s' % trait . info ()) lines . append ( '# Default: %s' % default_repr ) else : # Trait appears multiple times and isn 't defined here. # Truncate help to first line + \"See also Original.trait\" if trait.help: lines.append(c(trait.help.split(' \\ n ', 1)[0])) lines.append(' # See also : % s . % s ' % (defining_class.__name__, name)) lines.append(' # c . % s . % s = % s ' % (cls.__name__, name, default_repr)) lines.append('') return ' \\ n ' . join ( lines ) class_get_help def class_get_help ( inst = None ) Get the help string for this class in ReST format. If inst is given, it's current trait values will be used in place of class defaults. View Source @classmethod def class_get_help ( cls , inst = None ) : \" \"\" Get the help string for this class in ReST format. If `inst` is given, it's current trait values will be used in place of class defaults. \"\" \" assert inst is None or isinstance ( inst , cls ) final_help = [] base_classes = ', ' . join ( p . __name__ for p in cls . __bases__ ) final_help . append ( '%s(%s) options' % ( cls . __name__ , base_classes )) final_help . append ( len ( final_help [ 0 ] ) * '-' ) for k , v in sorted ( cls . class_traits ( config = True ). items ()) : help = cls . class_get_trait_help ( v , inst ) final_help . append ( help ) return ' \\n ' . join ( final_help ) class_get_trait_help def class_get_trait_help ( trait , inst = None , helptext = None ) Get the helptext string for a single trait. :param inst: If given, it's current trait values will be used in place of the class default. :param helptext: If not given, uses the help attribute of the current trait. View Source @classmethod def class_get_trait_help ( cls , trait , inst = None , helptext = None ) : \" \"\" Get the helptext string for a single trait. :param inst: If given, it's current trait values will be used in place of the class default. :param helptext: If not given, uses the `help` attribute of the current trait. \"\" \" assert inst is None or isinstance ( inst , cls ) lines = [] header = \"--%s.%s\" % ( cls . __name__ , trait . name ) if isinstance ( trait , ( Container , Dict )) : multiplicity = trait . metadata . get ( 'multiplicity' , 'append' ) if isinstance ( trait , Dict ) : sample_value = '<key-1>=<value-1>' else : sample_value = '<%s-item-1>' % trait . __class__ . __name__ . lower () if multiplicity == 'append' : header = \"%s=%s...\" % ( header , sample_value ) else : header = \"%s %s...\" % ( header , sample_value ) else : header = '%s=<%s>' % ( header , trait . __class__ . __name__ ) #header = \"--%s.%s=<%s>\" % (cls.__name__, trait.name, trait.__class__.__name__) lines . append ( header ) if helptext is None : helptext = trait . help if helptext != '' : helptext = ' \\n ' . join ( wrap_paragraphs ( helptext , 76 )) lines . append ( indent ( helptext , 4 )) if 'Enum' in trait . __class__ . __name__ : # include Enum choices lines . append ( indent ( 'Choices: %s' % trait . info ())) if inst is not None : lines . append ( indent ( 'Current: %r' % ( getattr ( inst , trait . name ),), 4 )) else : try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [ : 61 ] + '...' lines . append ( indent ( 'Default: %s' % dvr , 4 )) return ' \\n ' . join ( lines ) class_own_trait_events def class_own_trait_events ( name ) Get a dict of all event handlers defined on this class, not a parent. Works like event_handlers , except for excluding traits from parents. View Source @classmethod def class_own_trait_events ( cls , name ) : \" \"\" Get a dict of all event handlers defined on this class, not a parent. Works like ``event_handlers``, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : e for ( n , e ) in cls . events ( name ). items () if getattr ( sup , n , None ) is not e } class_own_traits def class_own_traits ( ** metadata ) Get a dict of all the traitlets defined on this class, not a parent. Works like class_traits , except for excluding traits from parents. View Source @classmethod def class_own_traits ( cls , ** metadata ) : \" \"\" Get a dict of all the traitlets defined on this class, not a parent. Works like `class_traits`, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : t for ( n , t ) in cls . class_traits ( ** metadata ). items () if getattr ( sup , n , None ) is not t } class_print_help def class_print_help ( inst = None ) Get the help string for a single trait and print it. View Source @classmethod def class_print_help ( cls , inst = None ) : \"\"\"Get the help string for a single trait and print it.\"\"\" print ( cls . class_get_help ( inst )) class_trait_names def class_trait_names ( ** metadata ) Get a list of all the names of this class' traits. This method is just like the :meth: trait_names method, but is unbound. View Source @classmethod def class_trait_names ( cls , ** metadata ) : \" \"\" Get a list of all the names of this class' traits. This method is just like the :meth:`trait_names` method, but is unbound. \"\" \" return list ( cls . class_traits ( ** metadata )) class_traits def class_traits ( ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth: traits method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source @classmethod def class_traits ( cls , ** metadata ) : \" \"\" Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth:`traits` method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\" \" traits = dict ( [ memb for memb in getmembers ( cls ) if isinstance ( memb [ 1 ] , TraitType ) ] ) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items () : for meta_name , meta_eval in metadata . items () : if not callable ( meta_eval ) : meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )) : break else : result [ name ] = trait return result section_names def section_names ( ) return section names as a list View Source @classmethod def section_names ( cls ) : \"\"\"return section names as a list\"\"\" return [ c.__name__ for c in reversed(cls.__mro__) if issubclass(c, Configurable) and issubclass(cls, c) ] trait_events def trait_events ( name = None ) Get a dict of all the event handlers of this class. Parameters name : str (default: None) The name of a trait of this class. If name is None then all the event handlers of this class will be returned instead. Returns The event handlers associated with a trait name, or all event handlers. View Source @classmethod def trait_events ( cls , name = None ) : \"\"\"Get a ``dict`` of all the event handlers of this class. Parameters ---------- name : str (default: None) The name of a trait of this class. If name is ``None`` then all the event handlers of this class will be returned instead. Returns ------- The event handlers associated with a trait name, or all event handlers. \"\"\" events = {} for k , v in getmembers ( cls ) : if isinstance ( v , EventHandler ) : if name is None : events [ k ] = v elif name in v . trait_names : events [ k ] = v elif hasattr ( v , 'tags' ) : if cls . trait_names ( ** v . tags ) : events [ k ] = v return events Instance variables cross_validation_lock A contextmanager for running a block with our cross validation lock set to True. At the end of the block, the lock's value is restored to its value prior to entering the block. Methods add_traits def add_traits ( self , ** traits ) Dynamically add trait attributes to the HasTraits instance. View Source def add_traits ( self , ** traits ): \"\"\"Dynamically add trait attributes to the HasTraits instance.\"\"\" cls = self . __class__ attrs = { \"__module__\" : cls . __module__ } if hasattr ( cls , \"__qualname__\" ): # __qualname__ introduced in Python 3 . 3 ( see PEP 3155 ) attrs [ \"__qualname__\" ] = cls . __qualname__ attrs . update ( traits ) self . __class__ = type ( cls . __name__ , ( cls ,), attrs ) for trait in traits . values (): trait . instance_init ( self ) arg_err def arg_err ( self , func ) Print docstring if incorrect arguments were passed View Source def arg_err ( self , func ): \"\"\"Print docstring if incorrect arguments were passed\"\"\" print ( 'Error in arguments:' ) print ( oinspect . getdoc ( func )) default_option def default_option ( self , fn , optstr ) Make an entry in the options_table for fn, with value optstr View Source def default_option ( self , fn , optstr ) : \"\"\"Make an entry in the options_table for fn, with value optstr\"\"\" if fn not in self . lsmagic () : error ( \"%s is not a magic function\" % fn ) self . options_table [ fn ] = optstr dotenv def dotenv ( self , line ) :: %dotenv [-o] [-v] [dotenv_path] positional arguments: dotenv_path Search in increasingly higher folders for the dotenv_path optional arguments: -o, --override Indicate to override existing variables -v, --verbose Indicate function calls to be verbose View Source @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) format_latex def format_latex ( self , strng ) Format a string for latex inclusion. View Source def format_latex ( self , strng ): \"\"\"Format a string for latex inclusion.\"\"\" # Characters that need to be escaped for latex : escape_re = re . compile ( r '(%|_|\\$|#|&)' , re . MULTILINE ) # Magic command names as headers : cmd_name_re = re . compile ( r '^(%s.*?):' % ESC_MAGIC , re . MULTILINE ) # Magic commands cmd_re = re . compile ( r '(?P<cmd>%s.+?\\b)(?!\\}\\}:)' % ESC_MAGIC , re . MULTILINE ) # Paragraph continue par_re = re . compile ( r '\\\\$' , re . MULTILINE ) # The \"\\n\" symbol newline_re = re . compile ( r '\\\\n' ) # Now build the string for output : # strng = cmd_name_re . sub ( r '\\n\\\\texttt{\\\\textsl{\\\\large \\1}}:' , strng ) strng = cmd_name_re . sub ( r '\\n\\\\bigskip\\n\\\\texttt{\\\\textbf{ \\1}}:' , strng ) strng = cmd_re . sub ( r '\\\\texttt{\\g<cmd>}' , strng ) strng = par_re . sub ( r '\\\\\\\\' , strng ) strng = escape_re . sub ( r '\\\\\\1' , strng ) strng = newline_re . sub ( r '\\\\textbackslash{}n' , strng ) return strng has_trait def has_trait ( self , name ) Returns True if the object has a trait with the specified name. View Source def has_trait ( self , name ): \"\"\"Returns True if the object has a trait with the specified name.\"\"\" return isinstance ( getattr ( self . __class__ , name , None ), TraitType ) hold_trait_notifications def hold_trait_notifications ( self ) Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. View Source @contextlib . contextmanager def hold_trait_notifications ( self ) : \"\"\"Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. \"\"\" if self . _ cross_validation_lock: yield return else : cache = {} notify_change = self . notify_change def compress ( past_changes , change ) : \"\"\"Merges the provided change with the last if possible.\"\"\" if past_changes is None : return [ change ] else : if past_changes [ - 1 ][ 'type' ] == 'change' and change . type == 'change': past_changes [ - 1 ][ 'new' ] = change . new else : # In case of changes other than 'change' , append the notification . past_changes . append ( change ) return past_changes def hold ( change ) : name = change . name cache [ name ] = compress ( cache . get ( name ), change ) try : # Replace notify_change with ` hold ` , caching and compressing # notifications , disable cross validation and yield . self . notify_change = hold self . _ cross_validation_lock = True yield # Cross validate final values when context is released . for name in list ( cache . keys ()) : trait = getattr ( self . __ class__ , name ) value = trait . _ cross_validate ( self , getattr ( self , name )) self . set_trait ( name , value ) except TraitError as e : # Roll back in case of TraitError during final cross validation . self . notify_change = lambda x : None for name , changes in cache . items () : for change in changes [ ::- 1 ] : # TODO : Separate in a rollback function per notification type . if change . type == 'change': if change . old is not Undefined : self . set_trait ( name , change . old ) else : self . _ trait_values . pop ( name ) cache = {} raise e finally : self . _ cross_validation_lock = False # Restore method retrieval from class del self . notify_change # trigger delayed notifications for changes in cache . values () : for change in changes : self . notify_change ( change ) notify_change def notify_change ( self , change ) Notify observers of a change event View Source def notify_change ( self , change ): \"\"\"Notify observers of a change event\"\"\" return self . _notify_observers ( change ) observe def observe ( self , handler , names = traitlets . All , type = 'change' ) Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters handler : callable A callable that is called when a trait changes. Its signature should be handler(change) , where change is a dictionary. The change dictionary at least holds a 'type' key. * type : the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * owner : the HasTraits instance * old : the old value of the modified trait attribute * new : the new value of the modified trait attribute * name : the name of the modified trait attribute. names : list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. type : str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. View Source def observe ( self , handler , names = All , type = 'change' ) : \" \"\" Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters ---------- handler : callable A callable that is called when a trait changes. Its signature should be ``handler(change)``, where ``change`` is a dictionary. The change dictionary at least holds a 'type' key. * ``type``: the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * ``owner`` : the HasTraits instance * ``old`` : the old value of the modified trait attribute * ``new`` : the new value of the modified trait attribute * ``name`` : the name of the modified trait attribute. names : list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. type : str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. \"\" \" names = parse_notifier_name ( names ) for n in names : self . _add_notifiers ( handler , n , type ) on_trait_change def on_trait_change ( self , handler = None , name = None , remove = False ) DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If remove is True and handler is not specified, all change handlers for the specified name are uninstalled. Parameters handler : callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). name : list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. remove : bool If False (the default), then install the handler. If True then unintall it. View Source def on_trait_change ( self , handler = None , name = None , remove = False ) : \" \"\" DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If `remove` is True and `handler` is not specified, all change handlers for the specified name are uninstalled. Parameters ---------- handler : callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). name : list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. remove : bool If False (the default), then install the handler. If True then unintall it. \"\" \" warn ( \"on_trait_change is deprecated in traitlets 4.1: use observe instead\" , DeprecationWarning , stacklevel = 2 ) if name is None : name = All if remove : self . unobserve ( _callback_wrapper ( handler ), names = name ) else : self . observe ( _callback_wrapper ( handler ), names = name ) parse_options def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) Parse options passed to an argument string. The interface is similar to that of :func: getopt.getopt , but it returns a :class: ~IPython.utils.struct.Struct with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters arg_str : str The arguments to parse. opt_str : str The options specification. mode : str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. list_all : bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. posix : bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod: shlex module from the standard library. View Source def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) : \"\"\"Parse options passed to an argument string. The interface is similar to that of :func:`getopt.getopt`, but it returns a :class:`~IPython.utils.struct.Struct` with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters ---------- arg_str : str The arguments to parse. opt_str : str The options specification. mode : str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. list_all : bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. posix : bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod:`shlex` module from the standard library. \"\"\" # inject default options at the beginning of the input line caller = sys . _getframe ( 1 ). f_code . co_name arg_str = '%s %s' % ( self . options_table . get ( caller , '' ), arg_str ) mode = kw . get ( 'mode' , 'string' ) if mode not in [ 'string','list' ] : raise ValueError ( 'incorrect mode given: %s' % mode ) # Get options list_all = kw . get ( 'list_all' , 0 ) posix = kw . get ( 'posix' , os . name == 'posix' ) strict = kw . get ( 'strict' , True ) # Check if we have more than one argument to warrant extra processing : odict = {} # Dictionary with options args = arg_str . split () if len ( args ) >= 1 : # If the list of inputs only has 0 or 1 thing in it , there 's no # need to look for options argv = arg_split(arg_str, posix, strict) # Do regular option processing try: opts,args = getopt(argv, opt_str, long_opts) except GetoptError as e: raise UsageError(' % s ( allowed : \"%s\" % s ) ' % (e.msg,opt_str, \" \".join(long_opts))) for o,a in opts: if o.startswith(' -- '): o = o[2:] else: o = o[1:] try: odict[o].append(a) except AttributeError: odict[o] = [odict[o],a] except KeyError: if list_all: odict[o] = [a] else: odict[o] = a # Prepare opts,args for return opts = Struct(odict) if mode == ' string ': args = ' ' . join ( args ) return opts , args set_trait def set_trait ( self , name , value ) Forcibly sets trait attribute, including read-only attributes. View Source def set_trait ( self , name , value ): \"\"\"Forcibly sets trait attribute, including read-only attributes.\"\"\" cls = self . __class__ if not self . has_trait ( name ): raise TraitError ( \"Class %s does not have a trait named %s\" % ( cls . __name__ , name )) else : getattr ( cls , name ). set ( self , value ) setup_instance def setup_instance ( * args , ** kwargs ) This is called before self. init is called. View Source def setup_instance ( * args , ** kwargs ): # Pass self as args [ 0 ] to allow \"self\" as keyword argument self = args [ 0 ] args = args [ 1 :] self . _trait_values = {} self . _trait_notifiers = {} self . _trait_validators = {} super ( HasTraits , self ). setup_instance ( * args , ** kwargs ) trait_defaults def trait_defaults ( self , * names , ** metadata ) Return a trait's default value or a dictionary of them Notes Dynamically generated default values may depend on the current state of the object. View Source def trait_defaults ( self , * names , ** metadata ) : \"\"\"Return a trait's default value or a dictionary of them Notes ----- Dynamically generated default values may depend on the current state of the object.\"\"\" for n in names : if not self . has_trait ( n ) : raise TraitError ( \"'%s' is not a trait of '%s' \" \"instances\" % ( n , type ( self ). __name__ )) if len ( names ) == 1 and len ( metadata ) == 0 : return self . _get_trait_default_generator ( names [ 0 ] )( self ) trait_names = self . trait_names ( ** metadata ) trait_names . extend ( names ) defaults = {} for n in trait_names : defaults [ n ] = self . _get_trait_default_generator ( n )( self ) return defaults trait_has_value def trait_has_value ( self , name ) Returns True if the specified trait has a value. This will return false even if getattr would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass ( HasTraits ): i = Int () mc = MyClass () assert not mc . trait_has_value ( \"i\" ) mc . i # generates a default value assert mc . trait_has_value ( \"i\" ) View Source def trait_has_value ( self , name ) : \" \"\" Returns True if the specified trait has a value. This will return false even if ``getattr`` would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass(HasTraits): i = Int() mc = MyClass() assert not mc.trait_has_value(\" i \") mc.i # generates a default value assert mc.trait_has_value(\" i \") \"\" \" return name in self . _trait_values trait_metadata def trait_metadata ( self , traitname , key , default = None ) Get metadata values for trait by key. View Source def trait_metadata ( self , traitname , key , default = None ): \"\"\"Get metadata values for trait by key.\"\"\" try : trait = getattr ( self . __class__ , traitname ) except AttributeError : raise TraitError ( \"Class %s does not have a trait named %s\" % ( self . __class__ . __name__ , traitname )) metadata_name = '_' + traitname + '_metadata' if hasattr ( self , metadata_name ) and key in getattr ( self , metadata_name ): return getattr ( self , metadata_name ). get ( key , default ) else : return trait . metadata . get ( key , default ) trait_names def trait_names ( self , ** metadata ) Get a list of all the names of this class' traits. View Source def trait_names ( self , ** metadata ): \"\"\"Get a list of all the names of this class' traits.\"\"\" return list ( self . traits ( ** metadata )) trait_values def trait_values ( self , ** metadata ) A dict of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns A dict of trait names and their values. Notes Trait values are retrieved via getattr , any exceptions raised by traits or the operations they may trigger will result in the absence of a trait value in the result dict . View Source def trait_values ( self , ** metadata ) : \" \"\" A ``dict`` of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns ------- A ``dict`` of trait names and their values. Notes ----- Trait values are retrieved via ``getattr``, any exceptions raised by traits or the operations they may trigger will result in the absence of a trait value in the result ``dict``. \"\" \" return { name : getattr ( self , name ) for name in self . trait_names ( ** metadata ) } traits def traits ( self , ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source def traits ( self , ** metadata ): \"\"\"Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\"\" traits = dict ([ memb for memb in getmembers ( self . __class__ ) if isinstance ( memb [ 1 ], TraitType )]) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items (): for meta_name , meta_eval in metadata . items (): if not callable ( meta_eval ): meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )): break else : result [ name ] = trait return result unobserve def unobserve ( self , handler , names = traitlets . All , type = 'change' ) Remove a trait change handler. This is used to unregister handlers to trait change notifications. Parameters handler : callable The callable called when a trait attribute changes. names : list, str, All (default: All) The names of the traits for which the specified handler should be uninstalled. If names is All, the specified handler is uninstalled from the list of notifiers corresponding to all changes. type : str or All (default: 'change') The type of notification to filter by. If All, the specified handler is uninstalled from the list of notifiers corresponding to all types. View Source def unobserve ( self , handler , names = All , type = ' change ') : \"\"\"Remove a trait change handler. This is used to unregister handlers to trait change notifications . Parameters ---------- handler : callable The callable called when a trait attribute changes . names : list , str , All ( default : All ) The names of the traits for which the specified handler should be uninstalled . If names is All , the specified handler is uninstalled from the list of notifiers corresponding to all changes . type : str or All ( default : ' change ') The type of notification to filter by . If All , the specified handler is uninstalled from the list of notifiers corresponding to all types . \"\"\" names = parse_notifier_name ( names ) for n in names: self . _remove_notifiers ( handler , n , type ) unobserve_all def unobserve_all ( self , name = traitlets . All ) Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers. View Source def unobserve_all ( self , name = All ) : \"\"\"Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers.\"\"\" if name is All : self . _trait_notifiers = {} else : try : del self . _trait_notifiers [ name ] except KeyError : pass update_config def update_config ( self , config ) Update config and load the new values View Source def update_config ( self , config ): \"\"\"Update config and load the new values\"\"\" # traitlets prior to 4.2 created a copy of self.config in order to trigger change events. # Some projects (IPython < 5) relied upon one side effect of this, # that self.config prior to update_config was not modified in-place. # For backward-compatibility, we must ensure that self.config # is a new object and not modified in-place, # but config consumers should not rely on this behavior. self . config = deepcopy ( self . config ) # load config self . _load_config ( config ) # merge it into self.config self . config . merge ( config ) # TODO: trigger change event if/when dict-update change events take place # DO NOT trigger full trait-change","title":"Ipython"},{"location":"reference/dotenv/ipython/#module-dotenvipython","text":"View Source from __future__ import print_function from IPython.core.magic import Magics , line_magic , magics_class # type: ignore from IPython.core.magic_arguments import ( argument , magic_arguments , # type: ignore parse_argstring ) # type: ignore from .main import find_dotenv , load_dotenv @magics_class class IPythonDotEnv ( Magics ): @magic_arguments () @argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override ) def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv )","title":"Module dotenv.ipython"},{"location":"reference/dotenv/ipython/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/ipython/#load_ipython_extension","text":"def load_ipython_extension ( ipython ) Register the %dotenv magic. View Source def load_ipython_extension ( ipython ): \"\"\"Register the %dotenv magic.\"\"\" ipython . register_magics ( IPythonDotEnv )","title":"load_ipython_extension"},{"location":"reference/dotenv/ipython/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/ipython/#ipythondotenv","text":"class IPythonDotEnv ( shell = None , ** kwargs ) Base class for implementing magic functions. Shell functions which can be reached as %function_name. All magic functions should accept a string, which they can parse for their own needs. This can make some functions easier to type, eg %cd ../ vs. %cd(\"../\") Classes providing magic functions need to subclass this class, and they MUST: Use the method decorators @line_magic and @cell_magic to decorate individual methods as magic functions, AND Use the class decorator @magics_class to ensure that the magic methods are properly registered at the instance level upon instance initialization. See :mod: magic_functions for examples of actual implementation classes. View Source @ magics_class class IPythonDotEnv ( Magics ): @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override )","title":"IPythonDotEnv"},{"location":"reference/dotenv/ipython/#ancestors-in-mro","text":"IPython.core.magic.Magics traitlets.config.configurable.Configurable traitlets.traitlets.HasTraits traitlets.traitlets.HasDescriptors","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/ipython/#class-variables","text":"config magics options_table parent registered shell","title":"Class variables"},{"location":"reference/dotenv/ipython/#static-methods","text":"","title":"Static methods"},{"location":"reference/dotenv/ipython/#class_config_rst_doc","text":"def class_config_rst_doc ( ) Generate rST documentation for this class' config options. Excludes traits defined on parent classes. View Source @ classmethod def class_config_rst_doc ( cls ): \"\"\"Generate rST documentation for this class' config options. Excludes traits defined on parent classes. \"\"\" lines = [] classname = cls . __name__ for k , trait in sorted ( cls . class_traits ( config = True ) . items ()): ttype = trait . __class__ . __name__ termline = classname + '.' + trait . name # Choices or type if 'Enum' in ttype : # include Enum choices termline += ' : ' + trait . info_rst () else : termline += ' : ' + ttype lines . append ( termline ) # Default value try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [: 61 ] + '...' # Double up backslashes, so they get to the rendered docs dvr = dvr . replace ( ' \\\\ n' , ' \\\\\\\\ n' ) lines . append ( indent ( 'Default: `` %s ``' % dvr , 4 )) lines . append ( '' ) help = trait . help or 'No description' lines . append ( indent ( dedent ( help ), 4 )) # Blank line lines . append ( '' ) return ' \\n ' . join ( lines )","title":"class_config_rst_doc"},{"location":"reference/dotenv/ipython/#class_config_section","text":"def class_config_section ( classes = None ) Get the config section for this class.","title":"class_config_section"},{"location":"reference/dotenv/ipython/#parameters","text":"classes : list, optional The list of other classes in the config file. Used to reduce redundant information. View Source @classmethod def class_config_section ( cls , classes = None ) : \"\"\"Get the config section for this class. Parameters ---------- classes : list, optional The list of other classes in the config file. Used to reduce redundant information. \"\"\" def c ( s ) : \"\"\"return a commented, wrapped block.\"\"\" s = '\\n\\n' . join ( wrap_paragraphs ( s , 78 )) return '## ' + s . replace ( '\\n' , '\\n# ' ) # section header breaker = '#' + '-' * 78 parent_classes = ', ' . join ( p . __name__ for p in cls . __bases__ if issubclass ( p , Configurable ) ) s = \"# %s(%s) configuration\" % ( cls . __name__ , parent_classes ) lines = [ breaker, s, breaker ] # get the description trait desc = cls . class_traits (). get ( 'description' ) if desc : desc = desc . default_value if not desc : # no description from trait , use __doc__ desc = getattr ( cls , '__doc__' , '' ) if desc : lines . append ( c ( desc )) lines . append ( '' ) for name , trait in sorted ( cls . class_traits ( config = True ). items ()) : default_repr = trait . default_value_repr () if classes : defining_class = cls . _defining_class ( trait , classes ) else : defining_class = cls if defining_class is cls : # cls owns the trait , show full help if trait . help : lines . append ( c ( trait . help )) if 'Enum' in type ( trait ). __name__ : # include Enum choices lines . append ( '# Choices: %s' % trait . info ()) lines . append ( '# Default: %s' % default_repr ) else : # Trait appears multiple times and isn 't defined here. # Truncate help to first line + \"See also Original.trait\" if trait.help: lines.append(c(trait.help.split(' \\ n ', 1)[0])) lines.append(' # See also : % s . % s ' % (defining_class.__name__, name)) lines.append(' # c . % s . % s = % s ' % (cls.__name__, name, default_repr)) lines.append('') return ' \\ n ' . join ( lines )","title":"Parameters"},{"location":"reference/dotenv/ipython/#class_get_help","text":"def class_get_help ( inst = None ) Get the help string for this class in ReST format. If inst is given, it's current trait values will be used in place of class defaults. View Source @classmethod def class_get_help ( cls , inst = None ) : \" \"\" Get the help string for this class in ReST format. If `inst` is given, it's current trait values will be used in place of class defaults. \"\" \" assert inst is None or isinstance ( inst , cls ) final_help = [] base_classes = ', ' . join ( p . __name__ for p in cls . __bases__ ) final_help . append ( '%s(%s) options' % ( cls . __name__ , base_classes )) final_help . append ( len ( final_help [ 0 ] ) * '-' ) for k , v in sorted ( cls . class_traits ( config = True ). items ()) : help = cls . class_get_trait_help ( v , inst ) final_help . append ( help ) return ' \\n ' . join ( final_help )","title":"class_get_help"},{"location":"reference/dotenv/ipython/#class_get_trait_help","text":"def class_get_trait_help ( trait , inst = None , helptext = None ) Get the helptext string for a single trait. :param inst: If given, it's current trait values will be used in place of the class default. :param helptext: If not given, uses the help attribute of the current trait. View Source @classmethod def class_get_trait_help ( cls , trait , inst = None , helptext = None ) : \" \"\" Get the helptext string for a single trait. :param inst: If given, it's current trait values will be used in place of the class default. :param helptext: If not given, uses the `help` attribute of the current trait. \"\" \" assert inst is None or isinstance ( inst , cls ) lines = [] header = \"--%s.%s\" % ( cls . __name__ , trait . name ) if isinstance ( trait , ( Container , Dict )) : multiplicity = trait . metadata . get ( 'multiplicity' , 'append' ) if isinstance ( trait , Dict ) : sample_value = '<key-1>=<value-1>' else : sample_value = '<%s-item-1>' % trait . __class__ . __name__ . lower () if multiplicity == 'append' : header = \"%s=%s...\" % ( header , sample_value ) else : header = \"%s %s...\" % ( header , sample_value ) else : header = '%s=<%s>' % ( header , trait . __class__ . __name__ ) #header = \"--%s.%s=<%s>\" % (cls.__name__, trait.name, trait.__class__.__name__) lines . append ( header ) if helptext is None : helptext = trait . help if helptext != '' : helptext = ' \\n ' . join ( wrap_paragraphs ( helptext , 76 )) lines . append ( indent ( helptext , 4 )) if 'Enum' in trait . __class__ . __name__ : # include Enum choices lines . append ( indent ( 'Choices: %s' % trait . info ())) if inst is not None : lines . append ( indent ( 'Current: %r' % ( getattr ( inst , trait . name ),), 4 )) else : try : dvr = trait . default_value_repr () except Exception : dvr = None # ignore defaults we can't construct if dvr is not None : if len ( dvr ) > 64 : dvr = dvr [ : 61 ] + '...' lines . append ( indent ( 'Default: %s' % dvr , 4 )) return ' \\n ' . join ( lines )","title":"class_get_trait_help"},{"location":"reference/dotenv/ipython/#class_own_trait_events","text":"def class_own_trait_events ( name ) Get a dict of all event handlers defined on this class, not a parent. Works like event_handlers , except for excluding traits from parents. View Source @classmethod def class_own_trait_events ( cls , name ) : \" \"\" Get a dict of all event handlers defined on this class, not a parent. Works like ``event_handlers``, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : e for ( n , e ) in cls . events ( name ). items () if getattr ( sup , n , None ) is not e }","title":"class_own_trait_events"},{"location":"reference/dotenv/ipython/#class_own_traits","text":"def class_own_traits ( ** metadata ) Get a dict of all the traitlets defined on this class, not a parent. Works like class_traits , except for excluding traits from parents. View Source @classmethod def class_own_traits ( cls , ** metadata ) : \" \"\" Get a dict of all the traitlets defined on this class, not a parent. Works like `class_traits`, except for excluding traits from parents. \"\" \" sup = super ( cls , cls ) return { n : t for ( n , t ) in cls . class_traits ( ** metadata ). items () if getattr ( sup , n , None ) is not t }","title":"class_own_traits"},{"location":"reference/dotenv/ipython/#class_print_help","text":"def class_print_help ( inst = None ) Get the help string for a single trait and print it. View Source @classmethod def class_print_help ( cls , inst = None ) : \"\"\"Get the help string for a single trait and print it.\"\"\" print ( cls . class_get_help ( inst ))","title":"class_print_help"},{"location":"reference/dotenv/ipython/#class_trait_names","text":"def class_trait_names ( ** metadata ) Get a list of all the names of this class' traits. This method is just like the :meth: trait_names method, but is unbound. View Source @classmethod def class_trait_names ( cls , ** metadata ) : \" \"\" Get a list of all the names of this class' traits. This method is just like the :meth:`trait_names` method, but is unbound. \"\" \" return list ( cls . class_traits ( ** metadata ))","title":"class_trait_names"},{"location":"reference/dotenv/ipython/#class_traits","text":"def class_traits ( ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth: traits method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source @classmethod def class_traits ( cls , ** metadata ) : \" \"\" Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. This method is just like the :meth:`traits` method, but is unbound. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\" \" traits = dict ( [ memb for memb in getmembers ( cls ) if isinstance ( memb [ 1 ] , TraitType ) ] ) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items () : for meta_name , meta_eval in metadata . items () : if not callable ( meta_eval ) : meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )) : break else : result [ name ] = trait return result","title":"class_traits"},{"location":"reference/dotenv/ipython/#section_names","text":"def section_names ( ) return section names as a list View Source @classmethod def section_names ( cls ) : \"\"\"return section names as a list\"\"\" return [ c.__name__ for c in reversed(cls.__mro__) if issubclass(c, Configurable) and issubclass(cls, c) ]","title":"section_names"},{"location":"reference/dotenv/ipython/#trait_events","text":"def trait_events ( name = None ) Get a dict of all the event handlers of this class.","title":"trait_events"},{"location":"reference/dotenv/ipython/#parameters_1","text":"name : str (default: None) The name of a trait of this class. If name is None then all the event handlers of this class will be returned instead.","title":"Parameters"},{"location":"reference/dotenv/ipython/#returns","text":"The event handlers associated with a trait name, or all event handlers. View Source @classmethod def trait_events ( cls , name = None ) : \"\"\"Get a ``dict`` of all the event handlers of this class. Parameters ---------- name : str (default: None) The name of a trait of this class. If name is ``None`` then all the event handlers of this class will be returned instead. Returns ------- The event handlers associated with a trait name, or all event handlers. \"\"\" events = {} for k , v in getmembers ( cls ) : if isinstance ( v , EventHandler ) : if name is None : events [ k ] = v elif name in v . trait_names : events [ k ] = v elif hasattr ( v , 'tags' ) : if cls . trait_names ( ** v . tags ) : events [ k ] = v return events","title":"Returns"},{"location":"reference/dotenv/ipython/#instance-variables","text":"cross_validation_lock A contextmanager for running a block with our cross validation lock set to True. At the end of the block, the lock's value is restored to its value prior to entering the block.","title":"Instance variables"},{"location":"reference/dotenv/ipython/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/ipython/#add_traits","text":"def add_traits ( self , ** traits ) Dynamically add trait attributes to the HasTraits instance. View Source def add_traits ( self , ** traits ): \"\"\"Dynamically add trait attributes to the HasTraits instance.\"\"\" cls = self . __class__ attrs = { \"__module__\" : cls . __module__ } if hasattr ( cls , \"__qualname__\" ): # __qualname__ introduced in Python 3 . 3 ( see PEP 3155 ) attrs [ \"__qualname__\" ] = cls . __qualname__ attrs . update ( traits ) self . __class__ = type ( cls . __name__ , ( cls ,), attrs ) for trait in traits . values (): trait . instance_init ( self )","title":"add_traits"},{"location":"reference/dotenv/ipython/#arg_err","text":"def arg_err ( self , func ) Print docstring if incorrect arguments were passed View Source def arg_err ( self , func ): \"\"\"Print docstring if incorrect arguments were passed\"\"\" print ( 'Error in arguments:' ) print ( oinspect . getdoc ( func ))","title":"arg_err"},{"location":"reference/dotenv/ipython/#default_option","text":"def default_option ( self , fn , optstr ) Make an entry in the options_table for fn, with value optstr View Source def default_option ( self , fn , optstr ) : \"\"\"Make an entry in the options_table for fn, with value optstr\"\"\" if fn not in self . lsmagic () : error ( \"%s is not a magic function\" % fn ) self . options_table [ fn ] = optstr","title":"default_option"},{"location":"reference/dotenv/ipython/#dotenv","text":"def dotenv ( self , line ) :: %dotenv [-o] [-v] [dotenv_path] positional arguments: dotenv_path Search in increasingly higher folders for the dotenv_path optional arguments: -o, --override Indicate to override existing variables -v, --verbose Indicate function calls to be verbose View Source @ magic_arguments () @ argument ( '-o' , '--override' , action = 'store_true' , help = \"Indicate to override existing variables\" ) @ argument ( '-v' , '--verbose' , action = 'store_true' , help = \"Indicate function calls to be verbose\" ) @ argument ( 'dotenv_path' , nargs = '?' , type = str , default = '.env' , help = 'Search in increasingly higher folders for the `dotenv_path`' ) @ line_magic def dotenv ( self , line ): args = parse_argstring ( self . dotenv , line ) # Locate the .env file dotenv_path = args . dotenv_path try : dotenv_path = find_dotenv ( dotenv_path , True , True ) except IOError : print ( \"cannot find .env file\" ) return # Load the .env file load_dotenv ( dotenv_path , verbose = args . verbose , override = args . override )","title":"dotenv"},{"location":"reference/dotenv/ipython/#format_latex","text":"def format_latex ( self , strng ) Format a string for latex inclusion. View Source def format_latex ( self , strng ): \"\"\"Format a string for latex inclusion.\"\"\" # Characters that need to be escaped for latex : escape_re = re . compile ( r '(%|_|\\$|#|&)' , re . MULTILINE ) # Magic command names as headers : cmd_name_re = re . compile ( r '^(%s.*?):' % ESC_MAGIC , re . MULTILINE ) # Magic commands cmd_re = re . compile ( r '(?P<cmd>%s.+?\\b)(?!\\}\\}:)' % ESC_MAGIC , re . MULTILINE ) # Paragraph continue par_re = re . compile ( r '\\\\$' , re . MULTILINE ) # The \"\\n\" symbol newline_re = re . compile ( r '\\\\n' ) # Now build the string for output : # strng = cmd_name_re . sub ( r '\\n\\\\texttt{\\\\textsl{\\\\large \\1}}:' , strng ) strng = cmd_name_re . sub ( r '\\n\\\\bigskip\\n\\\\texttt{\\\\textbf{ \\1}}:' , strng ) strng = cmd_re . sub ( r '\\\\texttt{\\g<cmd>}' , strng ) strng = par_re . sub ( r '\\\\\\\\' , strng ) strng = escape_re . sub ( r '\\\\\\1' , strng ) strng = newline_re . sub ( r '\\\\textbackslash{}n' , strng ) return strng","title":"format_latex"},{"location":"reference/dotenv/ipython/#has_trait","text":"def has_trait ( self , name ) Returns True if the object has a trait with the specified name. View Source def has_trait ( self , name ): \"\"\"Returns True if the object has a trait with the specified name.\"\"\" return isinstance ( getattr ( self . __class__ , name , None ), TraitType )","title":"has_trait"},{"location":"reference/dotenv/ipython/#hold_trait_notifications","text":"def hold_trait_notifications ( self ) Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. View Source @contextlib . contextmanager def hold_trait_notifications ( self ) : \"\"\"Context manager for bundling trait change notifications and cross validation. Use this when doing multiple trait assignments (init, config), to avoid race conditions in trait notifiers requesting other trait values. All trait notifications will fire after all values have been assigned. \"\"\" if self . _ cross_validation_lock: yield return else : cache = {} notify_change = self . notify_change def compress ( past_changes , change ) : \"\"\"Merges the provided change with the last if possible.\"\"\" if past_changes is None : return [ change ] else : if past_changes [ - 1 ][ 'type' ] == 'change' and change . type == 'change': past_changes [ - 1 ][ 'new' ] = change . new else : # In case of changes other than 'change' , append the notification . past_changes . append ( change ) return past_changes def hold ( change ) : name = change . name cache [ name ] = compress ( cache . get ( name ), change ) try : # Replace notify_change with ` hold ` , caching and compressing # notifications , disable cross validation and yield . self . notify_change = hold self . _ cross_validation_lock = True yield # Cross validate final values when context is released . for name in list ( cache . keys ()) : trait = getattr ( self . __ class__ , name ) value = trait . _ cross_validate ( self , getattr ( self , name )) self . set_trait ( name , value ) except TraitError as e : # Roll back in case of TraitError during final cross validation . self . notify_change = lambda x : None for name , changes in cache . items () : for change in changes [ ::- 1 ] : # TODO : Separate in a rollback function per notification type . if change . type == 'change': if change . old is not Undefined : self . set_trait ( name , change . old ) else : self . _ trait_values . pop ( name ) cache = {} raise e finally : self . _ cross_validation_lock = False # Restore method retrieval from class del self . notify_change # trigger delayed notifications for changes in cache . values () : for change in changes : self . notify_change ( change )","title":"hold_trait_notifications"},{"location":"reference/dotenv/ipython/#notify_change","text":"def notify_change ( self , change ) Notify observers of a change event View Source def notify_change ( self , change ): \"\"\"Notify observers of a change event\"\"\" return self . _notify_observers ( change )","title":"notify_change"},{"location":"reference/dotenv/ipython/#observe","text":"def observe ( self , handler , names = traitlets . All , type = 'change' ) Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes.","title":"observe"},{"location":"reference/dotenv/ipython/#parameters_2","text":"handler : callable A callable that is called when a trait changes. Its signature should be handler(change) , where change is a dictionary. The change dictionary at least holds a 'type' key. * type : the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * owner : the HasTraits instance * old : the old value of the modified trait attribute * new : the new value of the modified trait attribute * name : the name of the modified trait attribute. names : list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. type : str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. View Source def observe ( self , handler , names = All , type = 'change' ) : \" \"\" Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Parameters ---------- handler : callable A callable that is called when a trait changes. Its signature should be ``handler(change)``, where ``change`` is a dictionary. The change dictionary at least holds a 'type' key. * ``type``: the type of notification. Other keys may be passed depending on the value of 'type'. In the case where type is 'change', we also have the following keys: * ``owner`` : the HasTraits instance * ``old`` : the old value of the modified trait attribute * ``new`` : the new value of the modified trait attribute * ``name`` : the name of the modified trait attribute. names : list, str, All If names is All, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. type : str, All (default: 'change') The type of notification to filter by. If equal to All, then all notifications are passed to the observe handler. \"\" \" names = parse_notifier_name ( names ) for n in names : self . _add_notifiers ( handler , n , type )","title":"Parameters"},{"location":"reference/dotenv/ipython/#on_trait_change","text":"def on_trait_change ( self , handler = None , name = None , remove = False ) DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If remove is True and handler is not specified, all change handlers for the specified name are uninstalled.","title":"on_trait_change"},{"location":"reference/dotenv/ipython/#parameters_3","text":"handler : callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). name : list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. remove : bool If False (the default), then install the handler. If True then unintall it. View Source def on_trait_change ( self , handler = None , name = None , remove = False ) : \" \"\" DEPRECATED: Setup a handler to be called when a trait changes. This is used to setup dynamic notifications of trait changes. Static handlers can be created by creating methods on a HasTraits subclass with the naming convention '_[traitname]_changed'. Thus, to create static handler for the trait 'a', create the method _a_changed(self, name, old, new) (fewer arguments can be used, see below). If `remove` is True and `handler` is not specified, all change handlers for the specified name are uninstalled. Parameters ---------- handler : callable, None A callable that is called when a trait changes. Its signature can be handler(), handler(name), handler(name, new), handler(name, old, new), or handler(name, old, new, self). name : list, str, None If None, the handler will apply to all traits. If a list of str, handler will apply to all names in the list. If a str, the handler will apply just to that name. remove : bool If False (the default), then install the handler. If True then unintall it. \"\" \" warn ( \"on_trait_change is deprecated in traitlets 4.1: use observe instead\" , DeprecationWarning , stacklevel = 2 ) if name is None : name = All if remove : self . unobserve ( _callback_wrapper ( handler ), names = name ) else : self . observe ( _callback_wrapper ( handler ), names = name )","title":"Parameters"},{"location":"reference/dotenv/ipython/#parse_options","text":"def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) Parse options passed to an argument string. The interface is similar to that of :func: getopt.getopt , but it returns a :class: ~IPython.utils.struct.Struct with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc.","title":"parse_options"},{"location":"reference/dotenv/ipython/#parameters_4","text":"arg_str : str The arguments to parse. opt_str : str The options specification. mode : str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. list_all : bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. posix : bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod: shlex module from the standard library. View Source def parse_options ( self , arg_str , opt_str , * long_opts , ** kw ) : \"\"\"Parse options passed to an argument string. The interface is similar to that of :func:`getopt.getopt`, but it returns a :class:`~IPython.utils.struct.Struct` with the options as keys and the stripped argument string still as a string. arg_str is quoted as a true sys.argv vector by using shlex.split. This allows us to easily expand variables, glob files, quote arguments, etc. Parameters ---------- arg_str : str The arguments to parse. opt_str : str The options specification. mode : str, default 'string' If given as 'list', the argument string is returned as a list (split on whitespace) instead of a string. list_all : bool, default False Put all option values in lists. Normally only options appearing more than once are put in a list. posix : bool, default True Whether to split the input line in POSIX mode or not, as per the conventions outlined in the :mod:`shlex` module from the standard library. \"\"\" # inject default options at the beginning of the input line caller = sys . _getframe ( 1 ). f_code . co_name arg_str = '%s %s' % ( self . options_table . get ( caller , '' ), arg_str ) mode = kw . get ( 'mode' , 'string' ) if mode not in [ 'string','list' ] : raise ValueError ( 'incorrect mode given: %s' % mode ) # Get options list_all = kw . get ( 'list_all' , 0 ) posix = kw . get ( 'posix' , os . name == 'posix' ) strict = kw . get ( 'strict' , True ) # Check if we have more than one argument to warrant extra processing : odict = {} # Dictionary with options args = arg_str . split () if len ( args ) >= 1 : # If the list of inputs only has 0 or 1 thing in it , there 's no # need to look for options argv = arg_split(arg_str, posix, strict) # Do regular option processing try: opts,args = getopt(argv, opt_str, long_opts) except GetoptError as e: raise UsageError(' % s ( allowed : \"%s\" % s ) ' % (e.msg,opt_str, \" \".join(long_opts))) for o,a in opts: if o.startswith(' -- '): o = o[2:] else: o = o[1:] try: odict[o].append(a) except AttributeError: odict[o] = [odict[o],a] except KeyError: if list_all: odict[o] = [a] else: odict[o] = a # Prepare opts,args for return opts = Struct(odict) if mode == ' string ': args = ' ' . join ( args ) return opts , args","title":"Parameters"},{"location":"reference/dotenv/ipython/#set_trait","text":"def set_trait ( self , name , value ) Forcibly sets trait attribute, including read-only attributes. View Source def set_trait ( self , name , value ): \"\"\"Forcibly sets trait attribute, including read-only attributes.\"\"\" cls = self . __class__ if not self . has_trait ( name ): raise TraitError ( \"Class %s does not have a trait named %s\" % ( cls . __name__ , name )) else : getattr ( cls , name ). set ( self , value )","title":"set_trait"},{"location":"reference/dotenv/ipython/#setup_instance","text":"def setup_instance ( * args , ** kwargs ) This is called before self. init is called. View Source def setup_instance ( * args , ** kwargs ): # Pass self as args [ 0 ] to allow \"self\" as keyword argument self = args [ 0 ] args = args [ 1 :] self . _trait_values = {} self . _trait_notifiers = {} self . _trait_validators = {} super ( HasTraits , self ). setup_instance ( * args , ** kwargs )","title":"setup_instance"},{"location":"reference/dotenv/ipython/#trait_defaults","text":"def trait_defaults ( self , * names , ** metadata ) Return a trait's default value or a dictionary of them","title":"trait_defaults"},{"location":"reference/dotenv/ipython/#notes","text":"Dynamically generated default values may depend on the current state of the object. View Source def trait_defaults ( self , * names , ** metadata ) : \"\"\"Return a trait's default value or a dictionary of them Notes ----- Dynamically generated default values may depend on the current state of the object.\"\"\" for n in names : if not self . has_trait ( n ) : raise TraitError ( \"'%s' is not a trait of '%s' \" \"instances\" % ( n , type ( self ). __name__ )) if len ( names ) == 1 and len ( metadata ) == 0 : return self . _get_trait_default_generator ( names [ 0 ] )( self ) trait_names = self . trait_names ( ** metadata ) trait_names . extend ( names ) defaults = {} for n in trait_names : defaults [ n ] = self . _get_trait_default_generator ( n )( self ) return defaults","title":"Notes"},{"location":"reference/dotenv/ipython/#trait_has_value","text":"def trait_has_value ( self , name ) Returns True if the specified trait has a value. This will return false even if getattr would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass ( HasTraits ): i = Int () mc = MyClass () assert not mc . trait_has_value ( \"i\" ) mc . i # generates a default value assert mc . trait_has_value ( \"i\" ) View Source def trait_has_value ( self , name ) : \" \"\" Returns True if the specified trait has a value. This will return false even if ``getattr`` would return a dynamically generated default value. These default values will be recognized as existing only after they have been generated. Example .. code-block:: python class MyClass(HasTraits): i = Int() mc = MyClass() assert not mc.trait_has_value(\" i \") mc.i # generates a default value assert mc.trait_has_value(\" i \") \"\" \" return name in self . _trait_values","title":"trait_has_value"},{"location":"reference/dotenv/ipython/#trait_metadata","text":"def trait_metadata ( self , traitname , key , default = None ) Get metadata values for trait by key. View Source def trait_metadata ( self , traitname , key , default = None ): \"\"\"Get metadata values for trait by key.\"\"\" try : trait = getattr ( self . __class__ , traitname ) except AttributeError : raise TraitError ( \"Class %s does not have a trait named %s\" % ( self . __class__ . __name__ , traitname )) metadata_name = '_' + traitname + '_metadata' if hasattr ( self , metadata_name ) and key in getattr ( self , metadata_name ): return getattr ( self , metadata_name ). get ( key , default ) else : return trait . metadata . get ( key , default )","title":"trait_metadata"},{"location":"reference/dotenv/ipython/#trait_names","text":"def trait_names ( self , ** metadata ) Get a list of all the names of this class' traits. View Source def trait_names ( self , ** metadata ): \"\"\"Get a list of all the names of this class' traits.\"\"\" return list ( self . traits ( ** metadata ))","title":"trait_names"},{"location":"reference/dotenv/ipython/#trait_values","text":"def trait_values ( self , ** metadata ) A dict of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function.","title":"trait_values"},{"location":"reference/dotenv/ipython/#returns_1","text":"A dict of trait names and their values.","title":"Returns"},{"location":"reference/dotenv/ipython/#notes_1","text":"Trait values are retrieved via getattr , any exceptions raised by traits or the operations they may trigger will result in the absence of a trait value in the result dict . View Source def trait_values ( self , ** metadata ) : \" \"\" A ``dict`` of trait names and their values. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. Returns ------- A ``dict`` of trait names and their values. Notes ----- Trait values are retrieved via ``getattr``, any exceptions raised by traits or the operations they may trigger will result in the absence of a trait value in the result ``dict``. \"\" \" return { name : getattr ( self , name ) for name in self . trait_names ( ** metadata ) }","title":"Notes"},{"location":"reference/dotenv/ipython/#traits","text":"def traits ( self , ** metadata ) Get a dict of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. View Source def traits ( self , ** metadata ): \"\"\"Get a ``dict`` of all the traits of this class. The dictionary is keyed on the name and the values are the TraitType objects. The TraitTypes returned don't know anything about the values that the various HasTrait's instances are holding. The metadata kwargs allow functions to be passed in which filter traits based on metadata values. The functions should take a single value as an argument and return a boolean. If any function returns False, then the trait is not included in the output. If a metadata key doesn't exist, None will be passed to the function. \"\"\" traits = dict ([ memb for memb in getmembers ( self . __class__ ) if isinstance ( memb [ 1 ], TraitType )]) if len ( metadata ) == 0 : return traits result = {} for name , trait in traits . items (): for meta_name , meta_eval in metadata . items (): if not callable ( meta_eval ): meta_eval = _SimpleTest ( meta_eval ) if not meta_eval ( trait . metadata . get ( meta_name , None )): break else : result [ name ] = trait return result","title":"traits"},{"location":"reference/dotenv/ipython/#unobserve","text":"def unobserve ( self , handler , names = traitlets . All , type = 'change' ) Remove a trait change handler. This is used to unregister handlers to trait change notifications.","title":"unobserve"},{"location":"reference/dotenv/ipython/#parameters_5","text":"handler : callable The callable called when a trait attribute changes. names : list, str, All (default: All) The names of the traits for which the specified handler should be uninstalled. If names is All, the specified handler is uninstalled from the list of notifiers corresponding to all changes. type : str or All (default: 'change') The type of notification to filter by. If All, the specified handler is uninstalled from the list of notifiers corresponding to all types. View Source def unobserve ( self , handler , names = All , type = ' change ') : \"\"\"Remove a trait change handler. This is used to unregister handlers to trait change notifications . Parameters ---------- handler : callable The callable called when a trait attribute changes . names : list , str , All ( default : All ) The names of the traits for which the specified handler should be uninstalled . If names is All , the specified handler is uninstalled from the list of notifiers corresponding to all changes . type : str or All ( default : ' change ') The type of notification to filter by . If All , the specified handler is uninstalled from the list of notifiers corresponding to all types . \"\"\" names = parse_notifier_name ( names ) for n in names: self . _remove_notifiers ( handler , n , type )","title":"Parameters"},{"location":"reference/dotenv/ipython/#unobserve_all","text":"def unobserve_all ( self , name = traitlets . All ) Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers. View Source def unobserve_all ( self , name = All ) : \"\"\"Remove trait change handlers of any type for the specified name. If name is not specified, removes all trait notifiers.\"\"\" if name is All : self . _trait_notifiers = {} else : try : del self . _trait_notifiers [ name ] except KeyError : pass","title":"unobserve_all"},{"location":"reference/dotenv/ipython/#update_config","text":"def update_config ( self , config ) Update config and load the new values View Source def update_config ( self , config ): \"\"\"Update config and load the new values\"\"\" # traitlets prior to 4.2 created a copy of self.config in order to trigger change events. # Some projects (IPython < 5) relied upon one side effect of this, # that self.config prior to update_config was not modified in-place. # For backward-compatibility, we must ensure that self.config # is a new object and not modified in-place, # but config consumers should not rely on this behavior. self . config = deepcopy ( self . config ) # load config self . _load_config ( config ) # merge it into self.config self . config . merge ( config ) # TODO: trigger change event if/when dict-update change events take place # DO NOT trigger full trait-change","title":"update_config"},{"location":"reference/dotenv/main/","text":"Module dotenv.main View Source # -*- coding: utf-8 -*- from __future__ import absolute_import , print_function , unicode_literals import io import logging import os import shutil import sys import tempfile from collections import OrderedDict from contextlib import contextmanager from .compat import IS_TYPE_CHECKING , PY2 , StringIO , to_env from .parser import Binding , parse_stream from .variables import parse_variables logger = logging . getLogger ( __name__ ) if IS_TYPE_CHECKING : from typing import ( IO , Dict , Iterable , Iterator , Mapping , Optional , Text , Tuple , Union ) if sys . version_info >= ( 3 , 6 ): _PathLike = os . PathLike else : _PathLike = Text if sys . version_info >= ( 3 , 0 ): _StringIO = StringIO else : _StringIO = StringIO [ Text ] def with_warn_for_invalid_lines ( mappings ): # type: (Iterator[Binding]) -> Iterator[Binding] for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s \" , mapping . original . line , ) yield mapping class DotEnv (): def __init__ ( self , dotenv_path , verbose = False , encoding = None , interpolate = True , override = True ): # type: (Union[Text, _PathLike, _StringIO], bool, Union[None, Text], bool, bool) -> None self . dotenv_path = dotenv_path # type: Union[Text,_PathLike, _StringIO] self . _dict = None # type: Optional[Dict[Text, Optional[Text]]] self . verbose = verbose # type: bool self . encoding = encoding # type: Union[None, Text] self . interpolate = interpolate # type: bool self . override = override # type: bool @contextmanager def _get_stream ( self ): # type: () -> Iterator[IO[Text]] if isinstance ( self . dotenv_path , StringIO ): yield self . dotenv_path elif os . path . isfile ( self . dotenv_path ): with io . open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s .\" , self . dotenv_path or '.env' ) yield StringIO ( '' ) def dict ( self ): # type: () -> Dict[Text, Optional[Text]] \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ): # type: () -> Iterator[Tuple[Text, Optional[Text]]] with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )): if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ): # type: () -> bool \"\"\" Load the current dotenv as system environemt variable. \"\"\" for k , v in self . dict () . items (): if k in os . environ and not self . override : continue if v is not None : os . environ [ to_env ( k )] = to_env ( v ) return True def get ( self , key ): # type: (Text) -> Optional[Text] \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s .\" , key , self . dotenv_path ) return None def get_key ( dotenv_path , key_to_get ): # type: (Union[Text, _PathLike], Text) -> Optional[Text] \"\"\" Gets the value of a given key from the given .env If the .env path given doesn't exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ) . get ( key_to_get ) @contextmanager def rewrite ( path ): # type: (_PathLike) -> Iterator[Tuple[IO[Text], IO[Text]]] try : if not os . path . isfile ( path ): with io . open ( path , \"w+\" ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False ) as dest : with io . open ( path ) as source : yield ( source , dest ) # type: ignore except BaseException : if os . path . isfile ( dest . name ): os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path ) def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \"always\" , export = False ): # type: (_PathLike, Text, Text, Text, bool) -> Tuple[Optional[bool], Text, Text] \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \"'\" ) . strip ( '\"' ) if \" \" in value_to_set : quote_mode = \"always\" if quote_mode == \"always\" : value_out = '\"{}\"' . format ( value_to_set . replace ( '\"' , ' \\\\ \"' )) else : value_out = value_to_set if export : line_out = 'export {}={} \\n ' . format ( key_to_set , value_out ) else : line_out = \"{}={} \\n \" . format ( key_to_set , value_out ) with rewrite ( dotenv_path ) as ( source , dest ): replaced = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set def unset_key ( dotenv_path , key_to_unset , quote_mode = \"always\" ): # type: (_PathLike, Text, Text) -> Tuple[Optional[bool], Text] \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ): logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ): for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset def resolve_variables ( values , override ): # type: (Iterable[Tuple[Text, Optional[Text]]], bool) -> Mapping[Text, Optional[Text]] new_values = {} # type: Dict[Text, Optional[Text]] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type: Dict[Text, Optional[Text]] if override : env . update ( os . environ ) # type: ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type: ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values def _walk_to_root ( path ): # type: (Text) -> Iterator[Text] \"\"\" Yield directories starting from the given directory up to the root \"\"\" if not os . path . exists ( path ): raise IOError ( 'Starting path not found' ) if os . path . isfile ( path ): path = os . path . dirname ( path ) last_dir = None current_dir = os . path . abspath ( path ) while last_dir != current_dir : yield current_dir parent_dir = os . path . abspath ( os . path . join ( current_dir , os . path . pardir )) last_dir , current_dir = current_dir , parent_dir def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ): # type: (Text, bool, bool) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__, e.g. in REPL or IPython notebook. path = os . getcwd () else : # will work for .py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( '.py' ): # in Python2 __file__ extension could be .pyc or .pyo (this doesn't account # for edge case of Python compiled for non-standard extension) current_file = __file__ . rsplit ( '.' , 1 )[ 0 ] + '.py' else : current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ): check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ): return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return '' def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, bool, Union[None, Text]) -> bool \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: `StringIO` object with .env content. - *verbose*: whether to output the warnings related to missing .env file etc. Defaults to `False`. - *override*: where to override the system environment variables with the variables in `.env` file. Defaults to `False`. \"\"\" f = dotenv_path or stream or find_dotenv () dotenv = DotEnv ( f , verbose = verbose , interpolate = interpolate , override = override , ** kwargs ) return dotenv . set_as_environment_variables () def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, Union[None, Text]) -> Dict[Text, Optional[Text]] # noqa: E501 f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , interpolate = interpolate , override = True , ** kwargs ) . dict () Variables IS_TYPE_CHECKING PY2 logger Functions dotenv_values def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) View Source def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) : # type : ( Union [ Text, _PathLike, None ] , Optional [ _StringIO ] , bool , bool , Union [ None, Text ] ) -> Dict [ Text, Optional[Text ] ] # noqa : E501 f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , interpolate = interpolate , override = True , ** kwargs ). dict () find_dotenv def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ) Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ): # type : ( Text , bool , bool ) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( '.py' ): # in Python2 __file__ extension could be . pyc or . pyo ( this doesn 't account # for edge case of Python compiled for non-standard extension) current_file = __file__.rsplit(' . ', 1)[0] + ' . py ' else: current_file = __file__ while frame.f_code.co_filename == current_file: assert frame.f_back is not None frame = frame.f_back frame_filename = frame.f_code.co_filename path = os.path.dirname(os.path.abspath(frame_filename)) for dirname in _walk_to_root(path): check_path = os.path.join(dirname, filename) if os.path.isfile(check_path): return check_path if raise_error_if_not_found: raise IOError(' File not found ') return ' ' get_key def get_key ( dotenv_path , key_to_get ) Gets the value of a given key from the given .env If the .env path given doesn't exist, fails View Source def get_key ( dotenv_path , key_to_get ) : # type : ( Union [ Text, _PathLike ] , Text ) -> Optional [ Text ] \"\"\" Gets the value of a given key from the given .env If the .env path given doesn't exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ). get ( key_to_get ) load_dotenv def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ) Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : StringIO object with .env content. verbose : whether to output the warnings related to missing .env file etc. Defaults to False . override : where to override the system environment variables with the variables in .env file. Defaults to False . View Source def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, bool, Union[None, Text]) -> bool \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: `StringIO` object with .env content. - *verbose*: whether to output the warnings related to missing .env file etc. Defaults to `False`. - *override*: where to override the system environment variables with the variables in `.env` file. Defaults to `False`. \"\"\" f = dotenv_path or stream or find_dotenv () dotenv = DotEnv ( f , verbose = verbose , interpolate = interpolate , override = override , ** kwargs ) return dotenv . set_as_environment_variables () resolve_variables def resolve_variables ( values , override ) View Source def resolve_variables ( values , override ) : # type : ( Iterable [ Tuple[Text, Optional[Text ] ]] , bool ) -> Mapping [ Text, Optional[Text ] ] new_values = {} # type : Dict [ Text, Optional[Text ] ] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type : Dict [ Text, Optional[Text ] ] if override : env . update ( os . environ ) # type : ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type : ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values rewrite def rewrite ( path ) View Source @contextmanager def rewrite ( path ) : # type : ( _PathLike ) -> Iterator [ Tuple[IO[Text ] , IO [ Text ] ]] try : if not os . path . isfile ( path ) : with io . open ( path , \"w+\" ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False ) as dest : with io . open ( path ) as source : yield ( source , dest ) # type : ignore except BaseException : if os . path . isfile ( dest . name ) : os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path ) set_key def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = 'always' , export = False ) Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \"always\" , export = False ) : # type : ( _PathLike , Text , Text , Text , bool ) -> Tuple [ Optional[bool ] , Text , Text ] \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \"'\" ). strip ( '\"' ) if \" \" in value_to_set : quote_mode = \"always\" if quote_mode == \"always\" : value_out = '\"{}\"' . format ( value_to_set . replace ( '\"' , '\\\\\"' )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path ) as ( source , dest ) : replaced = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set unset_key def unset_key ( dotenv_path , key_to_unset , quote_mode = 'always' ) Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path , key_to_unset , quote_mode = \"always\" ) : # type : ( _PathLike , Text , Text ) -> Tuple [ Optional[bool ] , Text ] \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset with_warn_for_invalid_lines def with_warn_for_invalid_lines ( mappings ) View Source def with_warn_for_invalid_lines ( mappings ) : # type : ( Iterator [ Binding ] ) -> Iterator [ Binding ] for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s\" , mapping . original . line , ) yield mapping Classes DotEnv class DotEnv ( dotenv_path , verbose = False , encoding = None , interpolate = True , override = True ) View Source class DotEnv () : def __init__ ( self , dotenv_path , verbose = False , encoding = None , interpolate = True , override = True ) : # type : ( Union [ Text, _PathLike, _StringIO ] , bool , Union [ None, Text ] , bool , bool ) -> None self . dotenv_path = dotenv_path # type : Union [ Text,_PathLike, _StringIO ] self . _dict = None # type : Optional [ Dict[Text, Optional[Text ] ]] self . verbose = verbose # type : bool self . encoding = encoding # type : Union [ None, Text ] self . interpolate = interpolate # type : bool self . override = override # type : bool @contextmanager def _get_stream ( self ) : # type : () -> Iterator [ IO[Text ] ] if isinstance ( self . dotenv_path , StringIO ) : yield self . dotenv_path elif os . path . isfile ( self . dotenv_path ) : with io . open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s.\" , self . dotenv_path or '.env' ) yield StringIO ( '' ) def dict ( self ) : # type : () -> Dict [ Text, Optional[Text ] ] \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ) : # type : () -> Iterator [ Tuple[Text, Optional[Text ] ]] with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ) : # type : () -> bool \"\"\" Load the current dotenv as system environemt variable. \"\"\" for k , v in self . dict (). items () : if k in os . environ and not self . override : continue if v is not None : os . environ [ to_env(k) ] = to_env ( v ) return True def get ( self , key ) : # type : ( Text ) -> Optional [ Text ] \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None Methods dict def dict ( self ) Return dotenv as dict View Source def dict ( self ) : # type : () -> Dict [ Text, Optional[Text ] ] \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict get def get ( self , key ) View Source def get ( self , key ) : # type : ( Text ) -> Optional [ Text ] \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None parse def parse ( self ) View Source def parse ( self ) : # type : () -> Iterator [ Tuple[Text, Optional[Text ] ]] with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value set_as_environment_variables def set_as_environment_variables ( self ) Load the current dotenv as system environemt variable. View Source def set_as_environment_variables ( self ): # type: () -> bool \"\"\" Load the current dotenv as system environemt variable. \"\"\" for k , v in self . dict () . items (): if k in os . environ and not self . override : continue if v is not None : os . environ [ to_env ( k )] = to_env ( v ) return True","title":"Main"},{"location":"reference/dotenv/main/#module-dotenvmain","text":"View Source # -*- coding: utf-8 -*- from __future__ import absolute_import , print_function , unicode_literals import io import logging import os import shutil import sys import tempfile from collections import OrderedDict from contextlib import contextmanager from .compat import IS_TYPE_CHECKING , PY2 , StringIO , to_env from .parser import Binding , parse_stream from .variables import parse_variables logger = logging . getLogger ( __name__ ) if IS_TYPE_CHECKING : from typing import ( IO , Dict , Iterable , Iterator , Mapping , Optional , Text , Tuple , Union ) if sys . version_info >= ( 3 , 6 ): _PathLike = os . PathLike else : _PathLike = Text if sys . version_info >= ( 3 , 0 ): _StringIO = StringIO else : _StringIO = StringIO [ Text ] def with_warn_for_invalid_lines ( mappings ): # type: (Iterator[Binding]) -> Iterator[Binding] for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s \" , mapping . original . line , ) yield mapping class DotEnv (): def __init__ ( self , dotenv_path , verbose = False , encoding = None , interpolate = True , override = True ): # type: (Union[Text, _PathLike, _StringIO], bool, Union[None, Text], bool, bool) -> None self . dotenv_path = dotenv_path # type: Union[Text,_PathLike, _StringIO] self . _dict = None # type: Optional[Dict[Text, Optional[Text]]] self . verbose = verbose # type: bool self . encoding = encoding # type: Union[None, Text] self . interpolate = interpolate # type: bool self . override = override # type: bool @contextmanager def _get_stream ( self ): # type: () -> Iterator[IO[Text]] if isinstance ( self . dotenv_path , StringIO ): yield self . dotenv_path elif os . path . isfile ( self . dotenv_path ): with io . open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s .\" , self . dotenv_path or '.env' ) yield StringIO ( '' ) def dict ( self ): # type: () -> Dict[Text, Optional[Text]] \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ): # type: () -> Iterator[Tuple[Text, Optional[Text]]] with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )): if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ): # type: () -> bool \"\"\" Load the current dotenv as system environemt variable. \"\"\" for k , v in self . dict () . items (): if k in os . environ and not self . override : continue if v is not None : os . environ [ to_env ( k )] = to_env ( v ) return True def get ( self , key ): # type: (Text) -> Optional[Text] \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s .\" , key , self . dotenv_path ) return None def get_key ( dotenv_path , key_to_get ): # type: (Union[Text, _PathLike], Text) -> Optional[Text] \"\"\" Gets the value of a given key from the given .env If the .env path given doesn't exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ) . get ( key_to_get ) @contextmanager def rewrite ( path ): # type: (_PathLike) -> Iterator[Tuple[IO[Text], IO[Text]]] try : if not os . path . isfile ( path ): with io . open ( path , \"w+\" ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False ) as dest : with io . open ( path ) as source : yield ( source , dest ) # type: ignore except BaseException : if os . path . isfile ( dest . name ): os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path ) def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \"always\" , export = False ): # type: (_PathLike, Text, Text, Text, bool) -> Tuple[Optional[bool], Text, Text] \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \"'\" ) . strip ( '\"' ) if \" \" in value_to_set : quote_mode = \"always\" if quote_mode == \"always\" : value_out = '\"{}\"' . format ( value_to_set . replace ( '\"' , ' \\\\ \"' )) else : value_out = value_to_set if export : line_out = 'export {}={} \\n ' . format ( key_to_set , value_out ) else : line_out = \"{}={} \\n \" . format ( key_to_set , value_out ) with rewrite ( dotenv_path ) as ( source , dest ): replaced = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set def unset_key ( dotenv_path , key_to_unset , quote_mode = \"always\" ): # type: (_PathLike, Text, Text) -> Tuple[Optional[bool], Text] \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ): logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ): for mapping in with_warn_for_invalid_lines ( parse_stream ( source )): if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset def resolve_variables ( values , override ): # type: (Iterable[Tuple[Text, Optional[Text]]], bool) -> Mapping[Text, Optional[Text]] new_values = {} # type: Dict[Text, Optional[Text]] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type: Dict[Text, Optional[Text]] if override : env . update ( os . environ ) # type: ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type: ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values def _walk_to_root ( path ): # type: (Text) -> Iterator[Text] \"\"\" Yield directories starting from the given directory up to the root \"\"\" if not os . path . exists ( path ): raise IOError ( 'Starting path not found' ) if os . path . isfile ( path ): path = os . path . dirname ( path ) last_dir = None current_dir = os . path . abspath ( path ) while last_dir != current_dir : yield current_dir parent_dir = os . path . abspath ( os . path . join ( current_dir , os . path . pardir )) last_dir , current_dir = current_dir , parent_dir def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ): # type: (Text, bool, bool) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__, e.g. in REPL or IPython notebook. path = os . getcwd () else : # will work for .py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( '.py' ): # in Python2 __file__ extension could be .pyc or .pyo (this doesn't account # for edge case of Python compiled for non-standard extension) current_file = __file__ . rsplit ( '.' , 1 )[ 0 ] + '.py' else : current_file = __file__ while frame . f_code . co_filename == current_file : assert frame . f_back is not None frame = frame . f_back frame_filename = frame . f_code . co_filename path = os . path . dirname ( os . path . abspath ( frame_filename )) for dirname in _walk_to_root ( path ): check_path = os . path . join ( dirname , filename ) if os . path . isfile ( check_path ): return check_path if raise_error_if_not_found : raise IOError ( 'File not found' ) return '' def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, bool, Union[None, Text]) -> bool \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: `StringIO` object with .env content. - *verbose*: whether to output the warnings related to missing .env file etc. Defaults to `False`. - *override*: where to override the system environment variables with the variables in `.env` file. Defaults to `False`. \"\"\" f = dotenv_path or stream or find_dotenv () dotenv = DotEnv ( f , verbose = verbose , interpolate = interpolate , override = override , ** kwargs ) return dotenv . set_as_environment_variables () def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, Union[None, Text]) -> Dict[Text, Optional[Text]] # noqa: E501 f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , interpolate = interpolate , override = True , ** kwargs ) . dict ()","title":"Module dotenv.main"},{"location":"reference/dotenv/main/#variables","text":"IS_TYPE_CHECKING PY2 logger","title":"Variables"},{"location":"reference/dotenv/main/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/main/#dotenv_values","text":"def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) View Source def dotenv_values ( dotenv_path = None , stream = None , verbose = False , interpolate = True , ** kwargs ) : # type : ( Union [ Text, _PathLike, None ] , Optional [ _StringIO ] , bool , bool , Union [ None, Text ] ) -> Dict [ Text, Optional[Text ] ] # noqa : E501 f = dotenv_path or stream or find_dotenv () return DotEnv ( f , verbose = verbose , interpolate = interpolate , override = True , ** kwargs ). dict ()","title":"dotenv_values"},{"location":"reference/dotenv/main/#find_dotenv","text":"def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ) Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise View Source def find_dotenv ( filename = '.env' , raise_error_if_not_found = False , usecwd = False ): # type : ( Text , bool , bool ) -> Text \"\"\" Search in increasingly higher folders for the given file Returns path to the file if found, or an empty string otherwise \"\"\" def _is_interactive (): \"\"\" Decide whether this is running in a REPL or IPython notebook \"\"\" main = __import__ ( '__main__' , None , None , fromlist = [ '__file__' ]) return not hasattr ( main , '__file__' ) if usecwd or _is_interactive () or getattr ( sys , 'frozen' , False ): # Should work without __file__ , e . g . in REPL or IPython notebook . path = os . getcwd () else : # will work for . py files frame = sys . _getframe () # find first frame that is outside of this file if PY2 and not __file__ . endswith ( '.py' ): # in Python2 __file__ extension could be . pyc or . pyo ( this doesn 't account # for edge case of Python compiled for non-standard extension) current_file = __file__.rsplit(' . ', 1)[0] + ' . py ' else: current_file = __file__ while frame.f_code.co_filename == current_file: assert frame.f_back is not None frame = frame.f_back frame_filename = frame.f_code.co_filename path = os.path.dirname(os.path.abspath(frame_filename)) for dirname in _walk_to_root(path): check_path = os.path.join(dirname, filename) if os.path.isfile(check_path): return check_path if raise_error_if_not_found: raise IOError(' File not found ') return ' '","title":"find_dotenv"},{"location":"reference/dotenv/main/#get_key","text":"def get_key ( dotenv_path , key_to_get ) Gets the value of a given key from the given .env If the .env path given doesn't exist, fails View Source def get_key ( dotenv_path , key_to_get ) : # type : ( Union [ Text, _PathLike ] , Text ) -> Optional [ Text ] \"\"\" Gets the value of a given key from the given .env If the .env path given doesn't exist, fails \"\"\" return DotEnv ( dotenv_path , verbose = True ). get ( key_to_get )","title":"get_key"},{"location":"reference/dotenv/main/#load_dotenv","text":"def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ) Parse a .env file and then load all the variables found as environment variables. dotenv_path : absolute or relative path to .env file. stream : StringIO object with .env content. verbose : whether to output the warnings related to missing .env file etc. Defaults to False . override : where to override the system environment variables with the variables in .env file. Defaults to False . View Source def load_dotenv ( dotenv_path = None , stream = None , verbose = False , override = False , interpolate = True , ** kwargs ): # type: (Union[Text, _PathLike, None], Optional[_StringIO], bool, bool, bool, Union[None, Text]) -> bool \"\"\"Parse a .env file and then load all the variables found as environment variables. - *dotenv_path*: absolute or relative path to .env file. - *stream*: `StringIO` object with .env content. - *verbose*: whether to output the warnings related to missing .env file etc. Defaults to `False`. - *override*: where to override the system environment variables with the variables in `.env` file. Defaults to `False`. \"\"\" f = dotenv_path or stream or find_dotenv () dotenv = DotEnv ( f , verbose = verbose , interpolate = interpolate , override = override , ** kwargs ) return dotenv . set_as_environment_variables ()","title":"load_dotenv"},{"location":"reference/dotenv/main/#resolve_variables","text":"def resolve_variables ( values , override ) View Source def resolve_variables ( values , override ) : # type : ( Iterable [ Tuple[Text, Optional[Text ] ]] , bool ) -> Mapping [ Text, Optional[Text ] ] new_values = {} # type : Dict [ Text, Optional[Text ] ] for ( name , value ) in values : if value is None : result = None else : atoms = parse_variables ( value ) env = {} # type : Dict [ Text, Optional[Text ] ] if override : env . update ( os . environ ) # type : ignore env . update ( new_values ) else : env . update ( new_values ) env . update ( os . environ ) # type : ignore result = \"\" . join ( atom . resolve ( env ) for atom in atoms ) new_values [ name ] = result return new_values","title":"resolve_variables"},{"location":"reference/dotenv/main/#rewrite","text":"def rewrite ( path ) View Source @contextmanager def rewrite ( path ) : # type : ( _PathLike ) -> Iterator [ Tuple[IO[Text ] , IO [ Text ] ]] try : if not os . path . isfile ( path ) : with io . open ( path , \"w+\" ) as source : source . write ( \"\" ) with tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = False ) as dest : with io . open ( path ) as source : yield ( source , dest ) # type : ignore except BaseException : if os . path . isfile ( dest . name ) : os . unlink ( dest . name ) raise else : shutil . move ( dest . name , path )","title":"rewrite"},{"location":"reference/dotenv/main/#set_key","text":"def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = 'always' , export = False ) Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem View Source def set_key ( dotenv_path , key_to_set , value_to_set , quote_mode = \"always\" , export = False ) : # type : ( _PathLike , Text , Text , Text , bool ) -> Tuple [ Optional[bool ] , Text , Text ] \"\"\" Adds or Updates a key/value to the given .env If the .env path given doesn't exist, fails instead of risking creating an orphan .env somewhere in the filesystem \"\"\" value_to_set = value_to_set . strip ( \"'\" ). strip ( '\"' ) if \" \" in value_to_set : quote_mode = \"always\" if quote_mode == \"always\" : value_out = '\"{}\"' . format ( value_to_set . replace ( '\"' , '\\\\\"' )) else : value_out = value_to_set if export : line_out = 'export {}={}\\n' . format ( key_to_set , value_out ) else : line_out = \"{}={}\\n\" . format ( key_to_set , value_out ) with rewrite ( dotenv_path ) as ( source , dest ) : replaced = False for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_set : dest . write ( line_out ) replaced = True else : dest . write ( mapping . original . string ) if not replaced : dest . write ( line_out ) return True , key_to_set , value_to_set","title":"set_key"},{"location":"reference/dotenv/main/#unset_key","text":"def unset_key ( dotenv_path , key_to_unset , quote_mode = 'always' ) Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails View Source def unset_key ( dotenv_path , key_to_unset , quote_mode = \"always\" ) : # type : ( _PathLike , Text , Text ) -> Tuple [ Optional[bool ] , Text ] \"\"\" Removes a given key from the given .env If the .env path given doesn't exist, fails If the given key doesn't exist in the .env, fails \"\"\" if not os . path . exists ( dotenv_path ) : logger . warning ( \"Can't delete from %s - it doesn't exist.\" , dotenv_path ) return None , key_to_unset removed = False with rewrite ( dotenv_path ) as ( source , dest ) : for mapping in with_warn_for_invalid_lines ( parse_stream ( source )) : if mapping . key == key_to_unset : removed = True else : dest . write ( mapping . original . string ) if not removed : logger . warning ( \"Key %s not removed from %s - key doesn't exist.\" , key_to_unset , dotenv_path ) return None , key_to_unset return removed , key_to_unset","title":"unset_key"},{"location":"reference/dotenv/main/#with_warn_for_invalid_lines","text":"def with_warn_for_invalid_lines ( mappings ) View Source def with_warn_for_invalid_lines ( mappings ) : # type : ( Iterator [ Binding ] ) -> Iterator [ Binding ] for mapping in mappings : if mapping . error : logger . warning ( \"Python-dotenv could not parse statement starting at line %s\" , mapping . original . line , ) yield mapping","title":"with_warn_for_invalid_lines"},{"location":"reference/dotenv/main/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/main/#dotenv","text":"class DotEnv ( dotenv_path , verbose = False , encoding = None , interpolate = True , override = True ) View Source class DotEnv () : def __init__ ( self , dotenv_path , verbose = False , encoding = None , interpolate = True , override = True ) : # type : ( Union [ Text, _PathLike, _StringIO ] , bool , Union [ None, Text ] , bool , bool ) -> None self . dotenv_path = dotenv_path # type : Union [ Text,_PathLike, _StringIO ] self . _dict = None # type : Optional [ Dict[Text, Optional[Text ] ]] self . verbose = verbose # type : bool self . encoding = encoding # type : Union [ None, Text ] self . interpolate = interpolate # type : bool self . override = override # type : bool @contextmanager def _get_stream ( self ) : # type : () -> Iterator [ IO[Text ] ] if isinstance ( self . dotenv_path , StringIO ) : yield self . dotenv_path elif os . path . isfile ( self . dotenv_path ) : with io . open ( self . dotenv_path , encoding = self . encoding ) as stream : yield stream else : if self . verbose : logger . info ( \"Python-dotenv could not find configuration file %s.\" , self . dotenv_path or '.env' ) yield StringIO ( '' ) def dict ( self ) : # type : () -> Dict [ Text, Optional[Text ] ] \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict def parse ( self ) : # type : () -> Iterator [ Tuple[Text, Optional[Text ] ]] with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value def set_as_environment_variables ( self ) : # type : () -> bool \"\"\" Load the current dotenv as system environemt variable. \"\"\" for k , v in self . dict (). items () : if k in os . environ and not self . override : continue if v is not None : os . environ [ to_env(k) ] = to_env ( v ) return True def get ( self , key ) : # type : ( Text ) -> Optional [ Text ] \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None","title":"DotEnv"},{"location":"reference/dotenv/main/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/main/#dict","text":"def dict ( self ) Return dotenv as dict View Source def dict ( self ) : # type : () -> Dict [ Text, Optional[Text ] ] \"\"\"Return dotenv as dict\"\"\" if self . _dict : return self . _dict raw_values = self . parse () if self . interpolate : self . _dict = OrderedDict ( resolve_variables ( raw_values , override = self . override )) else : self . _dict = OrderedDict ( raw_values ) return self . _dict","title":"dict"},{"location":"reference/dotenv/main/#get","text":"def get ( self , key ) View Source def get ( self , key ) : # type : ( Text ) -> Optional [ Text ] \"\"\" \"\"\" data = self . dict () if key in data : return data [ key ] if self . verbose : logger . warning ( \"Key %s not found in %s.\" , key , self . dotenv_path ) return None","title":"get"},{"location":"reference/dotenv/main/#parse","text":"def parse ( self ) View Source def parse ( self ) : # type : () -> Iterator [ Tuple[Text, Optional[Text ] ]] with self . _get_stream () as stream : for mapping in with_warn_for_invalid_lines ( parse_stream ( stream )) : if mapping . key is not None : yield mapping . key , mapping . value","title":"parse"},{"location":"reference/dotenv/main/#set_as_environment_variables","text":"def set_as_environment_variables ( self ) Load the current dotenv as system environemt variable. View Source def set_as_environment_variables ( self ): # type: () -> bool \"\"\" Load the current dotenv as system environemt variable. \"\"\" for k , v in self . dict () . items (): if k in os . environ and not self . override : continue if v is not None : os . environ [ to_env ( k )] = to_env ( v ) return True","title":"set_as_environment_variables"},{"location":"reference/dotenv/parser/","text":"Module dotenv.parser View Source import codecs import re from .compat import IS_TYPE_CHECKING , to_text if IS_TYPE_CHECKING : from typing import ( # noqa:F401 IO , Iterator , Match , NamedTuple , Optional , Pattern , Sequence , Text , Tuple ) def make_regex ( string , extra_flags = 0 ): # type: (str, int) -> Pattern[Text] return re . compile ( to_text ( string ), re . UNICODE | extra_flags ) _newline = make_regex ( r \"(\\r\\n|\\n|\\r)\" ) _multiline_whitespace = make_regex ( r \"\\s*\" , extra_flags = re . MULTILINE ) _whitespace = make_regex ( r \"[^\\S\\r\\n]*\" ) _export = make_regex ( r \"(?:export[^\\S\\r\\n]+)?\" ) _single_quoted_key = make_regex ( r \"'([^']+)'\" ) _unquoted_key = make_regex ( r \"([^=\\#\\s]+)\" ) _equal_sign = make_regex ( r \"(=[^\\S\\r\\n]*)\" ) _single_quoted_value = make_regex ( r \"'((?: \\\\ '|[^'])*)'\" ) _double_quoted_value = make_regex ( r '\"((?: \\\\ \"|[^\"])*)\"' ) _unquoted_value = make_regex ( r \"([^\\r\\n]*)\" ) _comment = make_regex ( r \"(?:[^\\S\\r\\n]*#[^\\r\\n]*)?\" ) _end_of_line = make_regex ( r \"[^\\S\\r\\n]*(?:\\r\\n|\\n|\\r|$)\" ) _rest_of_line = make_regex ( r \"[^\\r\\n]*(?:\\r|\\n|\\r\\n)?\" ) _double_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ' \\\" abfnrtv]\" ) _single_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ']\" ) try : # this is necessary because we only import these from typing # when we are type checking, and the linter is upset if we # re-import import typing Original = typing . NamedTuple ( \"Original\" , [ ( \"string\" , typing . Text ), ( \"line\" , int ), ], ) Binding = typing . NamedTuple ( \"Binding\" , [ ( \"key\" , typing . Optional [ typing . Text ]), ( \"value\" , typing . Optional [ typing . Text ]), ( \"original\" , Original ), ( \"error\" , bool ), ], ) except ( ImportError , AttributeError ): from collections import namedtuple Original = namedtuple ( # type: ignore \"Original\" , [ \"string\" , \"line\" , ], ) Binding = namedtuple ( # type: ignore \"Binding\" , [ \"key\" , \"value\" , \"original\" , \"error\" , ], ) class Position : def __init__ ( self , chars , line ): # type: (int, int) -> None self . chars = chars self . line = line @classmethod def start ( cls ): # type: () -> Position return cls ( chars = 0 , line = 1 ) def set ( self , other ): # type: (Position) -> None self . chars = other . chars self . line = other . line def advance ( self , string ): # type: (Text) -> None self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) class Error ( Exception ): pass class Reader : def __init__ ( self , stream ): # type: (IO[Text]) -> None self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ): # type: () -> bool return self . position . chars < len ( self . string ) def set_mark ( self ): # type: () -> None self . mark . set ( self . position ) def get_marked ( self ): # type: () -> Original return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , ) def peek ( self , count ): # type: (int) -> Text return self . string [ self . position . chars : self . position . chars + count ] def read ( self , count ): # type: (int) -> Text result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex ): # type: (Pattern[Text]) -> Sequence[Text] match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match . start (): match . end ()]) return match . groups () def decode_escapes ( regex , string ): # type: (Pattern[Text], Text) -> Text def decode_match ( match ): # type: (Match[Text]) -> Text return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type: ignore return regex . sub ( decode_match , string ) def parse_key ( reader ): # type: (Reader) -> Optional[Text] char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key def parse_unquoted_value ( reader ): # type: (Reader) -> Text ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ) . rstrip () def parse_value ( reader ): # type: (Reader) -> Text char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ): return u \"\" else : return parse_unquoted_value ( reader ) def parse_binding ( reader ): # type: (Reader) -> Binding reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next (): return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type: Optional[Text] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , ) def parse_stream ( stream ): # type: (IO[Text]) -> Iterator[Binding] reader = Reader ( stream ) while reader . has_next (): yield parse_binding ( reader ) Variables IS_TYPE_CHECKING Functions decode_escapes def decode_escapes ( regex , string ) View Source def decode_escapes ( regex , string ) : # type : ( Pattern [ Text ] , Text ) -> Text def decode_match ( match ) : # type : ( Match [ Text ] ) -> Text return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type : ignore return regex . sub ( decode_match , string ) make_regex def make_regex ( string , extra_flags = 0 ) View Source def make_regex ( string , extra_flags = 0 ) : # type : ( str , int ) -> Pattern [ Text ] return re . compile ( to_text ( string ), re . UNICODE | extra_flags ) parse_binding def parse_binding ( reader ) View Source def parse_binding ( reader ) : # type : ( Reader ) -> Binding reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next () : return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type : Optional [ Text ] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , ) parse_key def parse_key ( reader ) View Source def parse_key ( reader ) : # type : ( Reader ) -> Optional [ Text ] char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key parse_stream def parse_stream ( stream ) View Source def parse_stream ( stream ) : # type : ( IO [ Text ] ) -> Iterator [ Binding ] reader = Reader ( stream ) while reader . has_next () : yield parse_binding ( reader ) parse_unquoted_value def parse_unquoted_value ( reader ) View Source def parse_unquoted_value ( reader ) : # type : ( Reader ) -> Text ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ). rstrip () parse_value def parse_value ( reader ) View Source def parse_value ( reader ) : # type : ( Reader ) -> Text char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ) : return u \"\" else : return parse_unquoted_value ( reader ) Classes Binding class Binding ( / , * args , ** kwargs ) Binding(key, value, original, error) Ancestors (in MRO) builtins.tuple Class variables error key original value Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. Error class Error ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class Error ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. Original class Original ( / , * args , ** kwargs ) Original(string, line) Ancestors (in MRO) builtins.tuple Class variables line string Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. Position class Position ( chars , line ) View Source class Position : def __init__ ( self , chars , line ) : # type : ( int , int ) -> None self . chars = chars self . line = line @classmethod def start ( cls ) : # type : () -> Position return cls ( chars = 0 , line = 1 ) def set ( self , other ) : # type : ( Position ) -> None self . chars = other . chars self . line = other . line def advance ( self , string ) : # type : ( Text ) -> None self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) Static methods start def start ( ) View Source @classmethod def start ( cls ) : # type : () -> Position return cls ( chars = 0 , line = 1 ) Methods advance def advance ( self , string ) View Source def advance ( self , string ): # type : ( Text ) -> None self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) set def set ( self , other ) View Source def set ( self , other ): # type : ( Position ) -> None self . chars = other . chars self . line = other . line Reader class Reader ( stream ) View Source class Reader : def __init__ ( self , stream ) : # type : ( IO [ Text ] ) -> None self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ) : # type : () -> bool return self . position . chars < len ( self . string ) def set_mark ( self ) : # type : () -> None self . mark . set ( self . position ) def get_marked ( self ) : # type : () -> Original return Original ( string = self . string [ self.mark.chars:self.position.chars ] , line = self . mark . line , ) def peek ( self , count ) : # type : ( int ) -> Text return self . string [ self.position.chars:self.position.chars + count ] def read ( self , count ) : # type : ( int ) -> Text result = self . string [ self.position.chars:self.position.chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex ) : # type : ( Pattern [ Text ] ) -> Sequence [ Text ] match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups () Methods get_marked def get_marked ( self ) View Source def get_marked ( self ): # type : () -> Original return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , ) has_next def has_next ( self ) View Source def has_next ( self ): # type : () -> bool return self . position . chars < len ( self . string ) peek def peek ( self , count ) View Source def peek ( self , count ): # type : ( int ) -> Text return self . string [ self . position . chars : self . position . chars + count ] read def read ( self , count ) View Source def read ( self , count ): # type : ( int ) -> Text result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result read_regex def read_regex ( self , regex ) View Source def read_regex ( self , regex ) : # type : ( Pattern [ Text ] ) -> Sequence [ Text ] match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups () set_mark def set_mark ( self ) View Source def set_mark ( self ): # type : () -> None self . mark . set ( self . position )","title":"Parser"},{"location":"reference/dotenv/parser/#module-dotenvparser","text":"View Source import codecs import re from .compat import IS_TYPE_CHECKING , to_text if IS_TYPE_CHECKING : from typing import ( # noqa:F401 IO , Iterator , Match , NamedTuple , Optional , Pattern , Sequence , Text , Tuple ) def make_regex ( string , extra_flags = 0 ): # type: (str, int) -> Pattern[Text] return re . compile ( to_text ( string ), re . UNICODE | extra_flags ) _newline = make_regex ( r \"(\\r\\n|\\n|\\r)\" ) _multiline_whitespace = make_regex ( r \"\\s*\" , extra_flags = re . MULTILINE ) _whitespace = make_regex ( r \"[^\\S\\r\\n]*\" ) _export = make_regex ( r \"(?:export[^\\S\\r\\n]+)?\" ) _single_quoted_key = make_regex ( r \"'([^']+)'\" ) _unquoted_key = make_regex ( r \"([^=\\#\\s]+)\" ) _equal_sign = make_regex ( r \"(=[^\\S\\r\\n]*)\" ) _single_quoted_value = make_regex ( r \"'((?: \\\\ '|[^'])*)'\" ) _double_quoted_value = make_regex ( r '\"((?: \\\\ \"|[^\"])*)\"' ) _unquoted_value = make_regex ( r \"([^\\r\\n]*)\" ) _comment = make_regex ( r \"(?:[^\\S\\r\\n]*#[^\\r\\n]*)?\" ) _end_of_line = make_regex ( r \"[^\\S\\r\\n]*(?:\\r\\n|\\n|\\r|$)\" ) _rest_of_line = make_regex ( r \"[^\\r\\n]*(?:\\r|\\n|\\r\\n)?\" ) _double_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ' \\\" abfnrtv]\" ) _single_quote_escapes = make_regex ( r \" \\\\ [ \\\\ ']\" ) try : # this is necessary because we only import these from typing # when we are type checking, and the linter is upset if we # re-import import typing Original = typing . NamedTuple ( \"Original\" , [ ( \"string\" , typing . Text ), ( \"line\" , int ), ], ) Binding = typing . NamedTuple ( \"Binding\" , [ ( \"key\" , typing . Optional [ typing . Text ]), ( \"value\" , typing . Optional [ typing . Text ]), ( \"original\" , Original ), ( \"error\" , bool ), ], ) except ( ImportError , AttributeError ): from collections import namedtuple Original = namedtuple ( # type: ignore \"Original\" , [ \"string\" , \"line\" , ], ) Binding = namedtuple ( # type: ignore \"Binding\" , [ \"key\" , \"value\" , \"original\" , \"error\" , ], ) class Position : def __init__ ( self , chars , line ): # type: (int, int) -> None self . chars = chars self . line = line @classmethod def start ( cls ): # type: () -> Position return cls ( chars = 0 , line = 1 ) def set ( self , other ): # type: (Position) -> None self . chars = other . chars self . line = other . line def advance ( self , string ): # type: (Text) -> None self . chars += len ( string ) self . line += len ( re . findall ( _newline , string )) class Error ( Exception ): pass class Reader : def __init__ ( self , stream ): # type: (IO[Text]) -> None self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ): # type: () -> bool return self . position . chars < len ( self . string ) def set_mark ( self ): # type: () -> None self . mark . set ( self . position ) def get_marked ( self ): # type: () -> Original return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , ) def peek ( self , count ): # type: (int) -> Text return self . string [ self . position . chars : self . position . chars + count ] def read ( self , count ): # type: (int) -> Text result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex ): # type: (Pattern[Text]) -> Sequence[Text] match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match . start (): match . end ()]) return match . groups () def decode_escapes ( regex , string ): # type: (Pattern[Text], Text) -> Text def decode_match ( match ): # type: (Match[Text]) -> Text return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type: ignore return regex . sub ( decode_match , string ) def parse_key ( reader ): # type: (Reader) -> Optional[Text] char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key def parse_unquoted_value ( reader ): # type: (Reader) -> Text ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ) . rstrip () def parse_value ( reader ): # type: (Reader) -> Text char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ): return u \"\" else : return parse_unquoted_value ( reader ) def parse_binding ( reader ): # type: (Reader) -> Binding reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next (): return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type: Optional[Text] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , ) def parse_stream ( stream ): # type: (IO[Text]) -> Iterator[Binding] reader = Reader ( stream ) while reader . has_next (): yield parse_binding ( reader )","title":"Module dotenv.parser"},{"location":"reference/dotenv/parser/#variables","text":"IS_TYPE_CHECKING","title":"Variables"},{"location":"reference/dotenv/parser/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/parser/#decode_escapes","text":"def decode_escapes ( regex , string ) View Source def decode_escapes ( regex , string ) : # type : ( Pattern [ Text ] , Text ) -> Text def decode_match ( match ) : # type : ( Match [ Text ] ) -> Text return codecs . decode ( match . group ( 0 ), 'unicode-escape' ) # type : ignore return regex . sub ( decode_match , string )","title":"decode_escapes"},{"location":"reference/dotenv/parser/#make_regex","text":"def make_regex ( string , extra_flags = 0 ) View Source def make_regex ( string , extra_flags = 0 ) : # type : ( str , int ) -> Pattern [ Text ] return re . compile ( to_text ( string ), re . UNICODE | extra_flags )","title":"make_regex"},{"location":"reference/dotenv/parser/#parse_binding","text":"def parse_binding ( reader ) View Source def parse_binding ( reader ) : # type : ( Reader ) -> Binding reader . set_mark () try : reader . read_regex ( _multiline_whitespace ) if not reader . has_next () : return Binding ( key = None , value = None , original = reader . get_marked (), error = False , ) reader . read_regex ( _export ) key = parse_key ( reader ) reader . read_regex ( _whitespace ) if reader . peek ( 1 ) == \"=\" : reader . read_regex ( _equal_sign ) value = parse_value ( reader ) # type : Optional [ Text ] else : value = None reader . read_regex ( _comment ) reader . read_regex ( _end_of_line ) return Binding ( key = key , value = value , original = reader . get_marked (), error = False , ) except Error : reader . read_regex ( _rest_of_line ) return Binding ( key = None , value = None , original = reader . get_marked (), error = True , )","title":"parse_binding"},{"location":"reference/dotenv/parser/#parse_key","text":"def parse_key ( reader ) View Source def parse_key ( reader ) : # type : ( Reader ) -> Optional [ Text ] char = reader . peek ( 1 ) if char == \"#\" : return None elif char == \"'\" : ( key ,) = reader . read_regex ( _single_quoted_key ) else : ( key ,) = reader . read_regex ( _unquoted_key ) return key","title":"parse_key"},{"location":"reference/dotenv/parser/#parse_stream","text":"def parse_stream ( stream ) View Source def parse_stream ( stream ) : # type : ( IO [ Text ] ) -> Iterator [ Binding ] reader = Reader ( stream ) while reader . has_next () : yield parse_binding ( reader )","title":"parse_stream"},{"location":"reference/dotenv/parser/#parse_unquoted_value","text":"def parse_unquoted_value ( reader ) View Source def parse_unquoted_value ( reader ) : # type : ( Reader ) -> Text ( part ,) = reader . read_regex ( _unquoted_value ) return re . sub ( r \"\\s+#.*\" , \"\" , part ). rstrip ()","title":"parse_unquoted_value"},{"location":"reference/dotenv/parser/#parse_value","text":"def parse_value ( reader ) View Source def parse_value ( reader ) : # type : ( Reader ) -> Text char = reader . peek ( 1 ) if char == u \"'\" : ( value ,) = reader . read_regex ( _single_quoted_value ) return decode_escapes ( _single_quote_escapes , value ) elif char == u '\"' : ( value ,) = reader . read_regex ( _double_quoted_value ) return decode_escapes ( _double_quote_escapes , value ) elif char in ( u \"\" , u \" \\n \" , u \" \\r \" ) : return u \"\" else : return parse_unquoted_value ( reader )","title":"parse_value"},{"location":"reference/dotenv/parser/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/parser/#binding","text":"class Binding ( / , * args , ** kwargs ) Binding(key, value, original, error)","title":"Binding"},{"location":"reference/dotenv/parser/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/parser/#class-variables","text":"error key original value","title":"Class variables"},{"location":"reference/dotenv/parser/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/dotenv/parser/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/dotenv/parser/#error","text":"class Error ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class Error ( Exception ): pass","title":"Error"},{"location":"reference/dotenv/parser/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/parser/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/dotenv/parser/#methods_1","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/dotenv/parser/#original","text":"class Original ( / , * args , ** kwargs ) Original(string, line)","title":"Original"},{"location":"reference/dotenv/parser/#ancestors-in-mro_2","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/parser/#class-variables_2","text":"line string","title":"Class variables"},{"location":"reference/dotenv/parser/#methods_2","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#count_1","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/dotenv/parser/#index_1","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/dotenv/parser/#position","text":"class Position ( chars , line ) View Source class Position : def __init__ ( self , chars , line ) : # type : ( int , int ) -> None self . chars = chars self . line = line @classmethod def start ( cls ) : # type : () -> Position return cls ( chars = 0 , line = 1 ) def set ( self , other ) : # type : ( Position ) -> None self . chars = other . chars self . line = other . line def advance ( self , string ) : # type : ( Text ) -> None self . chars += len ( string ) self . line += len ( re . findall ( _newline , string ))","title":"Position"},{"location":"reference/dotenv/parser/#static-methods","text":"","title":"Static methods"},{"location":"reference/dotenv/parser/#start","text":"def start ( ) View Source @classmethod def start ( cls ) : # type : () -> Position return cls ( chars = 0 , line = 1 )","title":"start"},{"location":"reference/dotenv/parser/#methods_3","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#advance","text":"def advance ( self , string ) View Source def advance ( self , string ): # type : ( Text ) -> None self . chars += len ( string ) self . line += len ( re . findall ( _newline , string ))","title":"advance"},{"location":"reference/dotenv/parser/#set","text":"def set ( self , other ) View Source def set ( self , other ): # type : ( Position ) -> None self . chars = other . chars self . line = other . line","title":"set"},{"location":"reference/dotenv/parser/#reader","text":"class Reader ( stream ) View Source class Reader : def __init__ ( self , stream ) : # type : ( IO [ Text ] ) -> None self . string = stream . read () self . position = Position . start () self . mark = Position . start () def has_next ( self ) : # type : () -> bool return self . position . chars < len ( self . string ) def set_mark ( self ) : # type : () -> None self . mark . set ( self . position ) def get_marked ( self ) : # type : () -> Original return Original ( string = self . string [ self.mark.chars:self.position.chars ] , line = self . mark . line , ) def peek ( self , count ) : # type : ( int ) -> Text return self . string [ self.position.chars:self.position.chars + count ] def read ( self , count ) : # type : ( int ) -> Text result = self . string [ self.position.chars:self.position.chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result def read_regex ( self , regex ) : # type : ( Pattern [ Text ] ) -> Sequence [ Text ] match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups ()","title":"Reader"},{"location":"reference/dotenv/parser/#methods_4","text":"","title":"Methods"},{"location":"reference/dotenv/parser/#get_marked","text":"def get_marked ( self ) View Source def get_marked ( self ): # type : () -> Original return Original ( string = self . string [ self . mark . chars : self . position . chars ], line = self . mark . line , )","title":"get_marked"},{"location":"reference/dotenv/parser/#has_next","text":"def has_next ( self ) View Source def has_next ( self ): # type : () -> bool return self . position . chars < len ( self . string )","title":"has_next"},{"location":"reference/dotenv/parser/#peek","text":"def peek ( self , count ) View Source def peek ( self , count ): # type : ( int ) -> Text return self . string [ self . position . chars : self . position . chars + count ]","title":"peek"},{"location":"reference/dotenv/parser/#read","text":"def read ( self , count ) View Source def read ( self , count ): # type : ( int ) -> Text result = self . string [ self . position . chars : self . position . chars + count ] if len ( result ) < count : raise Error ( \"read: End of string\" ) self . position . advance ( result ) return result","title":"read"},{"location":"reference/dotenv/parser/#read_regex","text":"def read_regex ( self , regex ) View Source def read_regex ( self , regex ) : # type : ( Pattern [ Text ] ) -> Sequence [ Text ] match = regex . match ( self . string , self . position . chars ) if match is None : raise Error ( \"read_regex: Pattern not found\" ) self . position . advance ( self . string [ match.start():match.end() ] ) return match . groups ()","title":"read_regex"},{"location":"reference/dotenv/parser/#set_mark","text":"def set_mark ( self ) View Source def set_mark ( self ): # type : () -> None self . mark . set ( self . position )","title":"set_mark"},{"location":"reference/dotenv/variables/","text":"Module dotenv.variables View Source import re from abc import ABCMeta from . compat import IS_TYPE_CHECKING if IS_TYPE_CHECKING : from typing import Iterator , Mapping , Optional , Pattern , Text _ posix_variable = re . compile ( r \"\" \" \\ $ \\ { ( ? P < name > [ ^\\ } : ] * ) ( ?::- ( ? P < default > [ ^\\ }] * ) ) ? \\ } \"\"\", re.VERBOSE, ) # type: Pattern[Text] class Atom(): __metaclass__ = ABCMeta def __ne__(self, other): # type: (object) -> bool result = self.__eq__(other) if result is NotImplemented: return NotImplemented return not result def resolve(self, env): # type: (Mapping[Text, Optional[Text]]) -> Text raise NotImplementedError class Literal(Atom): def __init__(self, value): # type: (Text) -> None self.value = value def __repr__(self): # type: () -> str return \" Literal ( value= {}) \".format(self.value) def __eq__(self, other): # type: (object) -> bool if not isinstance(other, self.__class__): return NotImplemented return self.value == other.value def __hash__(self): # type: () -> int return hash((self.__class__, self.value)) def resolve(self, env): # type: (Mapping[Text, Optional[Text]]) -> Text return self.value class Variable(Atom): def __init__(self, name, default): # type: (Text, Optional[Text]) -> None self.name = name self.default = default def __repr__(self): # type: () -> str return \" Variable ( name= {}, default= {}) \".format(self.name, self.default) def __eq__(self, other): # type: (object) -> bool if not isinstance(other, self.__class__): return NotImplemented return (self.name, self.default) == (other.name, other.default) def __hash__(self): # type: () -> int return hash((self.__class__, self.name, self.default)) def resolve(self, env): # type: (Mapping[Text, Optional[Text]]) -> Text default = self.default if self.default is not None else \"\" result = env.get(self.name, default) return result if result is not None else \"\" def parse_variables(value): # type: (Text) -> Iterator[Atom] cursor = 0 for match in _posix_variable.finditer(value): (start, end) = match.span() name = match.groupdict()[\" name \"] default = match.groupdict()[\" default \" ] if start > cursor : yield Literal ( value = value [ cursor : start ]) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor : length ]) Variables IS_TYPE_CHECKING Functions parse_variables def parse_variables ( value ) View Source def parse_variables ( value ) : # type : ( Text ) -> Iterator [ Atom ] cursor = 0 for match in _posix_variable . finditer ( value ) : ( start , end ) = match . span () name = match . groupdict () [ \"name\" ] default = match . groupdict () [ \"default\" ] if start > cursor : yield Literal ( value = value [ cursor:start ] ) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor:length ] ) Classes Atom class Atom ( / , * args , ** kwargs ) View Source class Atom () : __metaclass__ = ABCMeta def __ne__ ( self , other ) : # type : ( object ) -> bool result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text raise NotImplementedError Descendants dotenv.variables.Literal dotenv.variables.Variable Methods resolve def resolve ( self , env ) View Source def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text raise NotImplementedError Literal class Literal ( value ) View Source class Literal ( Atom ) : def __init__ ( self , value ) : # type : ( Text ) -> None self . value = value def __repr__ ( self ) : # type : () -> str return \"Literal(value={})\" . format ( self . value ) def __eq__ ( self , other ) : # type : ( object ) -> bool if not isinstance ( other , self . __class__ ) : return NotImplemented return self . value == other . value def __hash__ ( self ) : # type : () -> int return hash (( self . __class__ , self . value )) def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text return self . value Ancestors (in MRO) dotenv.variables.Atom Methods resolve def resolve ( self , env ) View Source def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text return self . value Variable class Variable ( name , default ) View Source class Variable ( Atom ) : def __init__ ( self , name , default ) : # type : ( Text , Optional [ Text ] ) -> None self . name = name self . default = default def __repr__ ( self ) : # type : () -> str return \"Variable(name={}, default={})\" . format ( self . name , self . default ) def __eq__ ( self , other ) : # type : ( object ) -> bool if not isinstance ( other , self . __class__ ) : return NotImplemented return ( self . name , self . default ) == ( other . name , other . default ) def __hash__ ( self ) : # type : () -> int return hash (( self . __class__ , self . name , self . default )) def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\" Ancestors (in MRO) dotenv.variables.Atom Methods resolve def resolve ( self , env ) View Source def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\"","title":"Variables"},{"location":"reference/dotenv/variables/#module-dotenvvariables","text":"View Source import re from abc import ABCMeta from . compat import IS_TYPE_CHECKING if IS_TYPE_CHECKING : from typing import Iterator , Mapping , Optional , Pattern , Text _ posix_variable = re . compile ( r \"\" \" \\ $ \\ { ( ? P < name > [ ^\\ } : ] * ) ( ?::- ( ? P < default > [ ^\\ }] * ) ) ? \\ } \"\"\", re.VERBOSE, ) # type: Pattern[Text] class Atom(): __metaclass__ = ABCMeta def __ne__(self, other): # type: (object) -> bool result = self.__eq__(other) if result is NotImplemented: return NotImplemented return not result def resolve(self, env): # type: (Mapping[Text, Optional[Text]]) -> Text raise NotImplementedError class Literal(Atom): def __init__(self, value): # type: (Text) -> None self.value = value def __repr__(self): # type: () -> str return \" Literal ( value= {}) \".format(self.value) def __eq__(self, other): # type: (object) -> bool if not isinstance(other, self.__class__): return NotImplemented return self.value == other.value def __hash__(self): # type: () -> int return hash((self.__class__, self.value)) def resolve(self, env): # type: (Mapping[Text, Optional[Text]]) -> Text return self.value class Variable(Atom): def __init__(self, name, default): # type: (Text, Optional[Text]) -> None self.name = name self.default = default def __repr__(self): # type: () -> str return \" Variable ( name= {}, default= {}) \".format(self.name, self.default) def __eq__(self, other): # type: (object) -> bool if not isinstance(other, self.__class__): return NotImplemented return (self.name, self.default) == (other.name, other.default) def __hash__(self): # type: () -> int return hash((self.__class__, self.name, self.default)) def resolve(self, env): # type: (Mapping[Text, Optional[Text]]) -> Text default = self.default if self.default is not None else \"\" result = env.get(self.name, default) return result if result is not None else \"\" def parse_variables(value): # type: (Text) -> Iterator[Atom] cursor = 0 for match in _posix_variable.finditer(value): (start, end) = match.span() name = match.groupdict()[\" name \"] default = match.groupdict()[\" default \" ] if start > cursor : yield Literal ( value = value [ cursor : start ]) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor : length ])","title":"Module dotenv.variables"},{"location":"reference/dotenv/variables/#variables","text":"IS_TYPE_CHECKING","title":"Variables"},{"location":"reference/dotenv/variables/#functions","text":"","title":"Functions"},{"location":"reference/dotenv/variables/#parse_variables","text":"def parse_variables ( value ) View Source def parse_variables ( value ) : # type : ( Text ) -> Iterator [ Atom ] cursor = 0 for match in _posix_variable . finditer ( value ) : ( start , end ) = match . span () name = match . groupdict () [ \"name\" ] default = match . groupdict () [ \"default\" ] if start > cursor : yield Literal ( value = value [ cursor:start ] ) yield Variable ( name = name , default = default ) cursor = end length = len ( value ) if cursor < length : yield Literal ( value = value [ cursor:length ] )","title":"parse_variables"},{"location":"reference/dotenv/variables/#classes","text":"","title":"Classes"},{"location":"reference/dotenv/variables/#atom","text":"class Atom ( / , * args , ** kwargs ) View Source class Atom () : __metaclass__ = ABCMeta def __ne__ ( self , other ) : # type : ( object ) -> bool result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text raise NotImplementedError","title":"Atom"},{"location":"reference/dotenv/variables/#descendants","text":"dotenv.variables.Literal dotenv.variables.Variable","title":"Descendants"},{"location":"reference/dotenv/variables/#methods","text":"","title":"Methods"},{"location":"reference/dotenv/variables/#resolve","text":"def resolve ( self , env ) View Source def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text raise NotImplementedError","title":"resolve"},{"location":"reference/dotenv/variables/#literal","text":"class Literal ( value ) View Source class Literal ( Atom ) : def __init__ ( self , value ) : # type : ( Text ) -> None self . value = value def __repr__ ( self ) : # type : () -> str return \"Literal(value={})\" . format ( self . value ) def __eq__ ( self , other ) : # type : ( object ) -> bool if not isinstance ( other , self . __class__ ) : return NotImplemented return self . value == other . value def __hash__ ( self ) : # type : () -> int return hash (( self . __class__ , self . value )) def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text return self . value","title":"Literal"},{"location":"reference/dotenv/variables/#ancestors-in-mro","text":"dotenv.variables.Atom","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/variables/#methods_1","text":"","title":"Methods"},{"location":"reference/dotenv/variables/#resolve_1","text":"def resolve ( self , env ) View Source def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text return self . value","title":"resolve"},{"location":"reference/dotenv/variables/#variable","text":"class Variable ( name , default ) View Source class Variable ( Atom ) : def __init__ ( self , name , default ) : # type : ( Text , Optional [ Text ] ) -> None self . name = name self . default = default def __repr__ ( self ) : # type : () -> str return \"Variable(name={}, default={})\" . format ( self . name , self . default ) def __eq__ ( self , other ) : # type : ( object ) -> bool if not isinstance ( other , self . __class__ ) : return NotImplemented return ( self . name , self . default ) == ( other . name , other . default ) def __hash__ ( self ) : # type : () -> int return hash (( self . __class__ , self . name , self . default )) def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\"","title":"Variable"},{"location":"reference/dotenv/variables/#ancestors-in-mro_1","text":"dotenv.variables.Atom","title":"Ancestors (in MRO)"},{"location":"reference/dotenv/variables/#methods_2","text":"","title":"Methods"},{"location":"reference/dotenv/variables/#resolve_2","text":"def resolve ( self , env ) View Source def resolve ( self , env ) : # type : ( Mapping [ Text, Optional[Text ] ] ) -> Text default = self . default if self . default is not None else \"\" result = env . get ( self . name , default ) return result if result is not None else \"\"","title":"resolve"},{"location":"reference/dotenv/version/","text":"Module dotenv.version View Source __version__ = \"0.15.0\"","title":"Version"},{"location":"reference/dotenv/version/#module-dotenvversion","text":"View Source __version__ = \"0.15.0\"","title":"Module dotenv.version"}]}